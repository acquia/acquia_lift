<?php

/**
 * @file
 * Integration tests for Acquia Lift module.
 */

class AcquiaLiftWebTest extends DrupalWebTestCase {
  /**
   * The string to use as the runtime API key.
   *
   * @var string
   */
  protected $liftAPIKey = 'api-key-123';

  /**
   * The string to use as the admin API key.
   *
   * @var string
   */
  protected $liftAdminKey = 'admin-key-123';

  /**
   * The string to use as the admin API URL.
   *
   * @var string
   */
  protected $liftAPIUrl = 'http://some.valid.url';

  /**
   * The string to use as the owner code.
   *
   * @var string
   */
  protected $liftAOwnerCode = 'Some_valid-owner123-code';

  protected $adminUser;

  protected $managerUser;

  protected $personalizedQueue;

  public static function getInfo() {
    return array(
      'name' => t('Acquia Lift Web Tests'),
      'description' => t('Tests basic functionality of Acquia Lift module.'),
      'group' => t('Personalize'),
    );
  }

  public function setUp() {
    require_once(dirname(__FILE__) . '/../includes/acquia_lift.classes.inc');
    require_once(dirname(__FILE__) . '/acquia_lift.test_classes.inc');

    parent::setUp(array('ctools', 'personalize', 'acquia_lift', 'personalize_blocks', 'personalize_test'));

    $this->adminUser = $this->drupalCreateUser(array('access administration pages', 'administer personalize configuration'));

    $this->managerUser = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer visitor actions'));
    $this->drupalLogin($this->managerUser);

    $this->personalizedQueue = DrupalQueue::get('acquia_lift_sync');

    variable_set('acquia_lift_account_info', array(
      'owner_code' => $this->liftAOwnerCode,
      'api_key' => $this->liftAPIKey,
      'admin_key' => $this->liftAdminKey,
    ));
  }

  public function testLiftAgentAvailibility() {
    // remove the account information
    $lift_info = variable_get('acquia_lift_account_info', array());
    variable_del('acquia_lift_account_info');
    $this->resetAll();

    // Try to add a new campaign and verify that the Acquia Lift agent isn't presented.
    $this->drupalGet('admin/structure/personalize/add');
    $this->assertText(t('Your Acquia Lift account info has not been configured.'));
    $this->assertNoRaw('<option value="acquia_lift">acquia_lift</option>');

    // Add the configuration information for the Lift account.
    $this->configureAcquiaLiftAccount();

    $this->drupalLogin($this->managerUser);

    // Now confirm that Acquia Lift is an option for new campaigns.
    $this->drupalGet('admin/structure/personalize/add');
    $this->assertNoText(t('Your Acquia Lift account info has not been configured.'));
    $this->assertRaw('<option value="acquia_lift">acquia_lift</option>');
  }

  public function testConfigForm() {
    $this->drupalLogin($this->adminUser);
    // Try entering an invalid owner code.
    $edit = array(
      'acquia_lift_account_info[owner_code]' => 'some invalid string',
      'acquia_lift_account_info[api_key]' => $this->liftAPIKey,
      'acquia_lift_account_info[admin_key]' => $this->liftAdminKey,
      'acquia_lift_account_info[api_url]' => $this->liftAPIUrl,
    );
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertText('You must enter a valid owner code');

    // Now try with a valid code.
    $edit['acquia_lift_account_info[owner_code]'] = $this->liftAOwnerCode;
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertNoText('You must enter a valid owner code');
    $account_info = variable_get('acquia_lift_account_info', array());
    $this->assertEqual($account_info['owner_code'], $this->liftAOwnerCode);
    $this->assertEqual($account_info['api_key'], $this->liftAPIKey);
    $this->assertEqual($account_info['admin_key'], $this->liftAdminKey);
    $this->assertEqual($account_info['api_url'], 'http://some.valid.url');
    // Try entering an invalid API url.
    $edit['acquia_lift_account_info[api_url]'] = 'some\\invalid\\url';
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertText('You must enter a valid URL');
    // Try a valid URL with no scheme.
    $edit['acquia_lift_account_info[api_url]'] = 'some.valid.url';
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertNoText('You must enter a valid URL');
    // Try a valid URL with scheme.
    $edit['acquia_lift_account_info[api_url]'] = 'https://some.valid.url';
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertNoText('You must enter a valid URL');
    $this->resetAll();
    $account_info = variable_get('acquia_lift_account_info', array());
    $this->assertEqual($account_info['api_url'], 'https://some.valid.url');

    // Submit bogus confidence measures.
    $bad_measures = array(
      'abcd' => t('Confidence measure must be a number.'),
      145 => t('Confidence measure must be a value between 0 and 100.'),
      -45 => t('Confidence measure must be a value between 0 and 100.'),
    );
    foreach ($bad_measures as $measure => $message) {
      $edit['acquia_lift_confidence_measure'] = $measure;
      $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
      $this->assertText($message);
      $this->assertNoText(t('A minimum confidence measure of 80% is recommended to ensure proper evaluation of test results.'));
      $this->assertNoText(t('The configuration options have been saved.'));
    }

    // Submit a low confidence measure and test warning.
    $edit['acquia_lift_confidence_measure'] = '10';
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertText(t('A minimum confidence measure of 95% is recommended to ensure proper evaluation of test results.'));
    $this->assertText(t('The configuration options have been saved.'));

    // Submit a valid measure and confirm it is saved without warning.
    $edit['acquia_lift_confidence_measure'] = '95';
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertNoText(t('A minimum confidence measure of 95% is recommended to ensure proper evaluation of test results.'));
    $this->assertText(t('The configuration options have been saved.'));
  }

  public function testSaveAgent() {
    // Create a new agent via the UI.
    $agent = $this->createTestAgent(array('control_rate' => 10, 'explore_rate' => 30));

    $agent_name = $agent->getTitle();
    $machine_name = $agent->getMachineName();
    $expected_queue_items = $option_set_queue_items = array();
    // Add some dummy option sets to this agent.
    $option_set_values = array(
      array('agent' => $machine_name, 'plugin' => 'type1', 'num_options' => 3),
      array('agent' => $machine_name, 'plugin' => 'type2', 'num_options' => 2),
    );

    foreach ($option_set_values as $i => $values) {
      list($option_set, $new_queues) = $this->createOptionSet($i, $values);

      $expected_queue_items = array_merge($expected_queue_items, $new_queues);

      // We need to keep track of the option set items that get added to the
      // queue separately from the other items as we need them again later.
      // Dirty way to avoid 'saveAgent' method be included to $option_set_queue_items
      $option_set_queue_items = array_merge($option_set_queue_items, $new_queues);
      $expected_queue_items[] = array(
        'method' => 'saveFixedTargetingMapping',
        'args' => array(
          $machine_name,
          personalize_get_decision_point_name_for_option_set($option_set),
          array()
        )
      );
      if ($i == 0) {
        $expected_queue_items[] = array(
          'method' => 'saveAgent',
          'args' => array(
            $machine_name,
            $agent_name,
            'adaptive',
            'enabled',
            0.1,
            0.3,
            1
          )
        );
      }
    }

    $this->assertQueueItems($expected_queue_items);
    $this->personalizedQueue->deleteQueue();
    $expected_queue_items = array();
    // Save a goal for the agent.
    $goal_name = 'form_submit';
    personalize_goal_save($machine_name, $goal_name, 2);
    $expected_queue_items[] = array(
      'method' => 'saveGoal',
      'args' => array(
        $machine_name,
        $goal_name
      )
    );
    $expected_queue_items[] = array(
      'method' => 'saveAgent',
      'args' => array(
        $machine_name,
        $agent_name,
        'adaptive',
        'enabled',
        0.1,
        0.3,
        1
      )
    );
    $this->assertQueueItems($expected_queue_items);
    $this->personalizedQueue->deleteQueue();
    $expected_queue_items = array();
    $this->drupalPost("admin/structure/personalize/manage/$machine_name/edit", array(), $this->getButton('agent'));
    $expected_queue_items = array(
      array(
        'method' => 'saveAgent',
        'args' => array(
          $machine_name,
          $agent_name,
          'adaptive',
          'enabled',
          0.1,
          0.3,
          1
        )
      )
    );
    $this->assertQueueItems($expected_queue_items);
    $this->personalizedQueue->deleteQueue();
    $expected_queue_items = array();
    $this->drupalPost("admin/structure/personalize/manage/$machine_name/edit", array(), $this->getButton('agent'));
    // Now the only thing that should get added is an item for the agent
    // because neither goals nor option sets will have changed.
    $expected_queue_items[] = array(
      'method' => 'saveAgent',
      'args' => array(
        $machine_name,
        $agent_name,
        'adaptive',
        'enabled',
        0.1,
        0.3,
        1
      )
    );
    $this->assertQueueItems($expected_queue_items);
    $this->personalizedQueue->deleteQueue();

    // Create an MVT and add the two option sets to it.
    $mvt_label = $this->randomName();
    $mvt_machine_name = personalize_generate_machine_name($mvt_label, 'personalize_mvt_machine_name_exists');
    $edit = array(
      'mvt[add][mvt_basic_info][label]' => $mvt_machine_name,
      'mvt[add][mvt_basic_info][option_sets][]' => array(1, 2),
    );
    $this->drupalPost("admin/structure/personalize/manage/{$machine_name}/edit", $edit, $this->getButton('mvt'));
    // The option sets will get added to the queue
    foreach ($option_set_queue_items as &$item) {
      // The second argument, which is the decision point name, will have
      // changed to the MVT name.
      $item['args'][1] = $mvt_machine_name;
    }
    $expected_queue_items = array_slice($option_set_queue_items, 0, 5);
    // @todo Commenting this out as for some reason after saving the new
    // point and decision/choices for osid-1, it saves the old point and
    // decision/choices for osid-2, before deleting the old osid-1 point,
    // saving the second decision and deleting the osid-2 point.
    //$this->assertQueueItems($expected_queue_items);
  }

  public function testSaveAutoTargetingRule() {
    $agent = $this->createTestAgent();

    // as acquia_lift_context options are fetched from Acquia Lift via webservice - use hardcoded ones in tests

    module_load_include('inc', 'personalize', 'personalize.admin');

    $agentStructure = _personalize_agent_from_form_values(array(
      'machine_name' => $agent->getMachineName(),
      'title' => $agent->getTitle(),
      'agent_type' => $agent->getType(),
      'data' => $agent->getData(),
    ));

    $agentStructure->data['visitor_context'] = array(
      // Fake Aquia Lift context to check saveAutoTargetingRule method queue
      'acquia_lift_context' => array(
        'some_acquia_lift_context' => 'some_acquia_lift_context',
      ),
    );

    $this->drupalGet('admin/structure/personalize/manage/' . $agent->getMachineName() . '/edit');
    personalize_agent_save($agentStructure);
    $this->drupalGet('admin/structure/personalize/manage/' . $agent->getMachineName() . '/edit');
    $agent = personalize_agent_load_agent($agent->getMachineName(), TRUE);

    $agentData = $agent->getData();
    $expected_queues = array(
      array(
        'method' => 'saveAgent',
        'args' => array(
          $agent->getMachineName(),
          $agent->getTitle(),
          $agentData['decision_style'],
          'enabled',
          0.1,
          0.2,
          1
        ),
      ),
      array(
        'method' => 'saveAutoTargetingRule',
        'args' => array(
          $agent->getMachineName(),
          array_keys(array_filter($agentData['visitor_context']['acquia_lift_context']))
        ),
      ),
    );

    $this->assertQueueItems($expected_queues);
    $this->personalizedQueue->deleteQueue();

    // Now remove the acquia_lift_context items and we should be sending a delete call
    // to Acquia Lift.
    $agentStructure->data['visitor_context'] = array(
      'acquia_lift_context' => array(),
    );

    $this->drupalGet('admin/structure/personalize/manage/' . $agent->getMachineName() . '/edit');
    personalize_agent_save($agentStructure);
    $this->drupalGet('admin/structure/personalize/manage/' . $agent->getMachineName() . '/edit');
    $agent = personalize_agent_load_agent($agent->getMachineName(), TRUE);

    $agentData = $agent->getData();
    $expected_queues = array(
      array(
        'method' => 'saveAgent',
        'args' => array(
          $agent->getMachineName(),
          $agent->getTitle(),
          $agentData['decision_style'],
          'enabled',
          0.1,
          0.2,
          1
        ),
      ),
      array(
        'method' => 'deleteAutoTargetingRule',
        'args' => array(
          $agent->getMachineName(),
        ),
      ),
    );

    $this->assertQueueItems($expected_queues);

  }


  /**
   * Tests syncing of Option Set information to Acquia Lift.
   */
  public function testSyncOptionSets() {
    $agent = $this->createTestAgent();

    // Create a couple of user profile fields for targeting.
    $user_profile_field_1 = $this->createUserProfileField();
    $user_profile_field_2 = $this->createUserProfileField();

    // Include _personalize_agent_from_form_values() function to build agent data.
    module_load_include('inc', 'personalize', 'personalize.admin');

    $agentStructure = _personalize_agent_from_form_values(array(
      'machine_name' => $agent->getMachineName(),
      'title' => $agent->getTitle(),
      'agent_type' => $agent->getType(),
      'data' => $agent->getData(),
    ));

    // Add the user profile fields as context.
    $agentStructure->data['visitor_context'] = array(
      'user_profile_context' => array (
        str_replace('field_', '', $user_profile_field_1['field_name']) => str_replace('field_', '', $user_profile_field_1['field_name']),
        str_replace('field_', '', $user_profile_field_2['field_name']) => str_replace('field_', '', $user_profile_field_2['field_name']),
      ),
    );

    personalize_agent_save($agentStructure);
    $agent = personalize_agent_load_agent($agent->getMachineName(), TRUE);

    $agentData = $agent->getData();
    $agent_queue_item = array(
      'method' => 'saveAgent',
      'args' => array(
        $agent->getMachineName(),
        $agent->getTitle(),
        $agentData['decision_style'],
        'enabled',
        ($agentData['control_rate'] / 100),
        ($agentData['explore_rate'] / 100),
        isset($agentData['cache_decisions']) && $agentData['cache_decisions']
      ),
    );
    $expected_queues = array(
      $agent_queue_item,
    );

    $this->assertQueueItems($expected_queues);
    $this->personalizedQueue->deleteQueue();
    $expected_queue_items = array();

    // Now add an option set to the agent.
    $personalized_blocks_form_state = array(
      'values' => array(
        'agent_select' => $agent->getMachineName(),
        'title' => $this->randomName(),
        'blocks' => array(
          array(
            'option_label' => 'Option A',
            'option_id' => 'option-A',
            'weight' => 0,
            'block' => array(
              'bid' => 'comment_delta_recent',
            ),
          ),
          array(
            'option_label' => 'Option B',
            'option_id' => 'option-B',
            'weight' => 1,
            'block' => array(
              'bid' => 'system_delta_main',
            ),
          ),
          array(
            'option_label' => 'Option C',
            'option_id' => 'option-C',
            'weight' => 2,
            'block' => array(
              'bid' => 'system_delta_help',
            ),
          ),
        ),
      ),
    );

    personalize_option_set_save(_personalize_blocks_convert_form_to_personalized_block($personalized_blocks_form_state));

    $option_sets = personalize_option_set_load_by_agent($agent->getMachineName(), TRUE);
    $osid = key($option_sets);
    $option_set = $option_sets[$osid];
    $point_name = personalize_get_decision_point_name_for_option_set($option_set);
    $decision_name = personalize_get_decision_name_for_option_set($option_set);

    $agent = personalize_agent_load_agent($agent->getMachineName(), TRUE);
    $agentData = $agent->getData();

    $this->assertTrue(isset($agentData['decisions']) && isset($agentData['decisions'][$osid]));

    $expected_queue_items['point'] = array(
      'method' => 'savePoint',
      'args' => array(
        $agent->getMachineName(),
        $point_name,
      )
    );
    $expected_queue_items['decision'] = array(
      'method' => 'saveDecision',
      'args' => array(
        $agent->getMachineName(),
        $point_name,
        $decision_name
      )
    );
    foreach ($option_set->options as $key => $option) {
      $expected_queue_items[$option['option_id']] = array(
        'method' => 'saveChoice',
        'args' => array(
          $agent->getMachineName(),
          $point_name,
          $decision_name,
          personalize_generate_option_id($key)
        )
      );
    }
    $expected_queue_items['targeting'] = array(
      'method' => 'saveFixedTargetingMapping',
      'args' => array(
        $agent->getMachineName(),
        $point_name,
        array()
      )
    );
    $expected_queue_items['agent'] = $agent_queue_item;

    $this->assertQueueItems(array_values($expected_queue_items));
    $this->personalizedQueue->deleteQueue();

    // Set up fixed targeting on Option A with two features OR'd together.
    $context_1 = str_replace('field_', '', $user_profile_field_1['field_name']);
    $context_2 = str_replace('field_', '', $user_profile_field_2['field_name']);

    // We can't use the form to add multiple fixed targeting contexts because we can't
    // make simpletest use the "Add context" button, so we send our form values directly
    // to the submit function.
    module_load_include('inc', 'personalize', 'personalize.admin');
    $form_state = array(
      'values' => array(
        'agent' => $agent->getMachineName(),
        'option_sets' => array(
          'option_set_1' => array(
            'winner' => 'option-A',
            'advanced' => array(
              'label' => $personalized_blocks_form_state['values']['title'],
              'stateful' => 0,
            ),
            'options' => array(
              'option-A' => array(
                'explicit_targeting' => array(
                  'mapping' => array(
                    'contexts' => array(
                      array(
                        'context' => 'user_profile_context' . PERSONALIZE_TARGETING_ADMIN_SEPARATOR . $context_1,
                        'value' => array('match' => 'some value', 'operator' => 'equals'),
                      ),
                      array(
                        'context' => 'user_profile_context' . PERSONALIZE_TARGETING_ADMIN_SEPARATOR . $context_2,
                        'value' => array('match' => 'some other value', 'operator' => 'contains'),
                      )
                    )
                  ),
                  'strategy' => 'OR',
                )
              ),
            )
          )
        )
      )
    );
    personalize_agent_option_sets_form_submit(array(), $form_state);
    $feature_1 = $context_1 . '::some-value';
    $feature_2 = $context_2 . '::sc-some-other-value';
    $expected_queue_items['targeting']['args'][2] = array(
      array(
        'feature' => $feature_1,
        'decision' => $decision_name . ':option-A'
      ),
      array(
        'feature' => $feature_2,
        'decision' => $decision_name . ':option-A'
      ),
    );

    $this->assertQueueItems(array_values($expected_queue_items));
    $this->personalizedQueue->deleteQueue();

    // Change the fixed targeting strategy to AND the features together.
    $edit = array(
      'option_sets[option_set_1][options][option-A][explicit_targeting][strategy]' => 'AND'
    );

    $this->drupalPost('admin/structure/personalize/manage/' . $agent->getMachineName() . '/edit', $edit , $this->getButton('option'));

    // Now the fixed targeting mapping should have a single mapping with
    // comma-separated features.
    $expected_queue_items['targeting']['args'][2] = array(
      array(
        'feature' => $feature_1 . ',' . $feature_2,
        'decision' => $decision_name . ':option-A'
      ),
    );
    $this->assertQueueItems(array_values($expected_queue_items));
    $this->personalizedQueue->deleteQueue();

    // Remove Option B
    $this->drupalGet('admin/structure/personalize/variations/personalize-blocks/manage/' . $osid . '/edit');
    $this->drupalPost(NULL, array(), 'remove_1');
    $this->drupalPost(NULL, array(), t('Save'));
    $expected_queue_items['delete-B'] = array(
      'method' => 'deleteChoice',
      'args' => array(
        $agent->getMachineName(),
        $point_name,
        $decision_name,
        'option-B',
      ),
    );
    $new_queue_items = array();
    $expected_order = array('point', 'decision', 'option-A', 'option-C', 'delete-B', 'targeting', 'agent');
    foreach ($expected_order as $key) {
      $new_queue_items[$key] = $expected_queue_items[$key];
    }

    $this->assertQueueItems(array_values($new_queue_items));
    $this->personalizedQueue->deleteQueue();
  }

  public function testSyncGoalsFromCampaignUI() {
    $agent = $this->createTestAgent();

    $edit = array(
      'goals[0][action_name]' => 'form_submit',
      'goals[0][value]' => '20',
    );

    $this->drupalPost('admin/structure/personalize/manage/' . $agent->getMachineName() . '/edit', $edit, $this->getButton('goal'));

    $expected_queues = array(
      array(
        'method' => 'saveGoal',
        'args' => array(
          $agent->getMachineName(),
          'form_submit',
        ),
      ),
      array(
        'method' => 'saveAgent',
        'args' => array(
          $agent->getMachineName(),
          $agent->getTitle(),
          'adaptive',
          'enabled',
          0.1,
          0.2,
          1
        ),
      ),
    );

    $this->assertQueueItems($expected_queues);
    $this->personalizedQueue->deleteQueue();

    $this->drupalPost('admin/structure/personalize/manage/' . $agent->getMachineName() . '/edit', array(), $this->getButton('goal'));

    // As we're triggering only goals form and do not change anything
    // saveAgent won't be invoked also
    $expected_queues = array();

    $this->assertQueueItems($expected_queues);
    $this->personalizedQueue->deleteQueue();
  }

  public function testSyncGoalsFromVisitorUI() {
    // include visitor_actions_action_name_exists() function to validate action machine name
    module_load_include('inc', 'visitor_actions', 'visitor_actions.admin');

    $agent = $this->createTestAgent();

    $actionTitle = $this->randomName();
    $actionMachineName = personalize_generate_machine_name($actionTitle, 'visitor_actions_action_name_exists');

    // Create new Visitor Action but WITHOUT connection to active agent
    $edit = array(
      'title' => $actionTitle,
      'machine_name' => $actionMachineName,
      'actionable_element' => 'form',
      'identifier[form]' => 'some_form_id',
      'event[form]' => 'server::submit_server',
      'personalize_goal' => FALSE,
      'personalize_goal_value' => 50,
    );

    $this->drupalPost('admin/structure/visitor_actions/add', $edit, $this->getButton());

    // Without connection to the agent we should run any acquia_lift' syncing
    // @see personalize_visitor_action_form_submit()
    $expected_queues = array();

    $this->assertQueueItems($expected_queues);

    // Try to create new with connection to the agent
    $actionTitle = $this->randomName();
    $actionMachineName = personalize_generate_machine_name($actionTitle, 'visitor_actions_action_name_exists');

    // Create new Visitor Action but WITH connection to active agent
    $edit = array(
      'title' => $actionTitle,
      'machine_name' => $actionMachineName,
      'actionable_element' => 'form',
      'identifier[form]' => 'some_form_id',
      'event[form]' => 'server::submit_server',
      'personalize_goal' => TRUE,
      'personalize_goal_value' => 50,
    );

    $this->drupalPost('admin/structure/visitor_actions/add', $edit, $this->getButton());

    // With connection to the agent we should run AcquiaLiftAgent->syncGoals
    $expected_queues = array(
      array(
        'method' => 'saveGoal',
        'args' => array(
          $agent->getMachineName(),
          $actionMachineName,
        ),
      ),
      array(
        'method' => 'saveAgent',
        'args' => array(
          $agent->getMachineName(),
          $agent->getTitle(),
          'adaptive',
          'enabled',
          0.1,
          0.2,
          1
        ),
      ),
    );

    $this->assertQueueItems($expected_queues);
    $this->personalizedQueue->deleteQueue();

    // Remove machine name from post because it's not available as a field in the edit form.
    unset($edit['machine_name']);
    // Try to modify with same goal value to check that anything won't be synced
    $this->drupalPost('admin/structure/visitor_actions/manage/' . $actionMachineName . '/edit', $edit, $this->getButton());

    // With connection to the agent but with old goal value we should not run AcquiaLiftAgent->syncGoals or saveAgent
    $expected_queues = array();

    $this->assertQueueItems($expected_queues);
    $this->personalizedQueue->deleteQueue();

    // If goal value is changed syncGoals and saveAgent should be invoked
    $edit['personalize_goal_value'] += 10;
    $this->drupalPost('admin/structure/visitor_actions/manage/' . $actionMachineName . '/edit', $edit, $this->getButton());

    // With connection to the agent but with old goal value we should not run AcquiaLiftAgent->syncGoals or saveAgent
    $expected_queues = array(
      array(
        'method' => 'saveGoal',
        'args' => array(
          $agent->getMachineName(),
          $actionMachineName,
        ),
      ),
      array(
        'method' => 'saveAgent',
        'args' => array(
          $agent->getMachineName(),
          $agent->getTitle(),
          'adaptive',
          'enabled',
          0.1,
          0.2,
          1
        ),
      ),
    );

    $this->assertQueueItems($expected_queues);
    $this->personalizedQueue->deleteQueue();

    // Verify that agent has last visitor action data
    $agentGoals = personalize_goal_load_by_conditions(array('agent' => $agent->getMachineName()));

    $this->assertEqual($agentGoals[0]['action'], $actionMachineName);
    $this->assertEqual($agentGoals[0]['value'], $edit['personalize_goal_value']);

    // Try to delete goal that connected to Agent from Visitor Action UI
    $this->drupalPost('admin/structure/visitor_actions/manage/' . $actionMachineName . '/delete', array(), t('Delete'));

    $expected_queues = array();

    // @todo uncomment or remove it after goal deletion decision
//    $expected_queues = array(
//      array(
//        'method' => 'saveAgent',
//        'args' => array(
//          $agent->getMachineName(),
//          $agent->getTitle(),
//          'adaptive',
//          'enabled',
//           0,
//        ),
//      ),
//    );

    $this->assertQueueItems($expected_queues);
    $this->personalizedQueue->deleteQueue();

    // No goal should be attached after deletion
    $agentGoals = personalize_goal_load_by_conditions(array('agent' => $agent->getMachineName()));

    $this->assertEqual($agentGoals, array());
  }

  public function testDeleteAgentGoals() {
    // @todo implement or remove it after goal deletion decision
  }

  public function testAcquiaLiftQueue() {
    $marketer = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($marketer);
    // Create a new agent via the UI.
    $agent = $this->createTestAgent(array(), FALSE);
    $agent_name = $agent->getTitle();
    $machine_name = $agent->getMachineName();

    // There should now be a js setting for triggering queue processing.
    $settings = $this->drupalGetSettings();
    $this->assertEqual(1, $settings['acquia_lift']['sync_queue']);
    $expected_queue_items = array();
    $queued_agent_item = array(
      'method' => 'saveAgent',
      'args' => array(
        $machine_name,
        $agent_name,
        'adaptive',
        'enabled',
        0.1,
        0.2,
        1
      )
    );
    $expected_queue_items[] = $queued_agent_item;
    $this->assertQueueItems($expected_queue_items);
    // Now cause the queue to be processed, which would normally happen
    // via an ajax request.
    $this->drupalGet('acquia_lift/queue');
    // Confirm that the queue is now empty.
    $this->assertQueueItems(array());
    $this->drupalGet('admin/structure/personalize');
    $this->assertNoText(t('At least one of your agents has configuration that has not been fully sync\'d to Acquia Lift. This should resolve itself on the next cron run.'));

    // Now save it again but don't process the queue.
    $this->drupalPost("admin/structure/personalize/manage/$machine_name/edit", array(), $this->getButton('agent'));
    // Save a goal for the agent.
    $goal_name = 'form_submit';
    personalize_goal_save($machine_name, $goal_name, 2);
    $expected_queue_items = array();
    $expected_queue_items[] = $queued_agent_item;
    $expected_queue_items[] = array(
      'method' => 'saveGoal',
      'args' => array(
        $machine_name,
        $goal_name
      )
    );
    $expected_queue_items[] = $queued_agent_item;
    $this->assertQueueItems($expected_queue_items);

    // Since we can't simulate the queued requests timing out during a web
    // test, we simply unset the queue trigger session without processing
    // the queue.
    $this->assertTrue(isset($_SESSION['acquia_lift_queue_trigger']));
    // Log the user out and back in again to get rid of the session variable.
    $this->drupalLogout();
    $this->drupalLogin($marketer);

    // Now they should get a message warning them that there are items that
    // need to get sync'd to Acquia Lift.
    $this->drupalGet('admin/structure/personalize');
    $this->assertText(t('At least one of your agents has configuration that has not been fully sync\'d to Acquia Lift. This should resolve itself on the next cron run.'));

    $this->drupalLogout();
    $admin_user = $this->drupalCreateUser(array('administer site configuration', 'access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    $this->drupalGet('admin/structure/personalize');
    $this->assertRaw(t('At least one of your agents has configuration that has not been fully sync\'d to Acquia Lift. This should resolve itself on the next cron run.') . t(' Click here to <a href="@cron">run cron manually</a>.', array('@cron' => url('admin/reports/status/run-cron'))));
    // Now run cron
    $this->drupalGet('admin/reports/status/run-cron');
    $this->assertQueueItems(array());
  }

  /**
   * Tests the logic in AcquiaLiftAgent's implementation of convertContextToFeatureString().
   */
  public function testConvertContextToFeatureString() {
    // No truncation should happen if name and value are short enough.
    $name = $this->randomName(20);
    $value = $this->randomName(20);
    $string = AcquiaLiftAgent::convertContextToFeatureString($name, $value);
    $expected = $name . '::' . $value;
    $this->assertEqual($expected, $string);
    $string = AcquiaLiftAgent::convertContextToFeatureString($name, $value, TRUE);
    $expected = $name . ':' . $value;
    $this->assertEqual($expected, $string);
    // If we have a really long name and value test that they are truncated
    // correctly.
    $long_name = $this->randomName(40);
    $long_value = $this->randomName(40);
    $string = AcquiaLiftAgent::convertContextToFeatureString($long_name, $long_value);
    $expected = substr($long_name, 0, 24) . '::' . substr($long_value, 0, 24);
    $this->assertEqual($expected, $string);
    $string = AcquiaLiftAgent::convertContextToFeatureString($long_name, $long_value, TRUE);
    $expected = substr($long_name, 0, 24) . ':' . substr($long_value, 0, 25);
    $this->assertEqual($expected, $string);
  }


  /**
   * Tests that new agents on the site cannot override existing agents in Lift.
   */
  public function testMachineNameValidation() {
    $test_data = array(
      'agents' => array(
        array('code' => 'my-existing-agent'),
      ),
    );
    variable_set('acquia_lift_web_test_data', $test_data);

    // Try to create a new agent with the same name as one that exists in Lift.
    $this->createTestAgent(array('name' => 'my-existing-agent', 'control_rate' => 10, 'explore_rate' => 30), TRUE, FALSE);
    $this->resetAll();
    $agent = personalize_agent_load_agent('my-existing-agent');
    $this->assertNull($agent);
    $agent = personalize_agent_load_agent('my-existing-agent-0');
    $this->assertTrue($agent instanceof AcquiaLiftAgentInterface);
  }

  /**
   * Tests the function that gathers operations for syncing of agents and their
   * components to Lift.
   */
  public function testBatchSyncOperations() {
    // Create an agent on the site with a couple of option sets.
    // Note: we do this part first rather than loading the test data to
    // the server because otherwise it wouldn't allow us to create an
    // agent with the same name as an existing one.
    $control_rate = 10;
    $explore_rate = 30;
    $this->createTestAgent(array('name' => 'first-existing-agent', 'control_rate' => $control_rate, 'explore_rate' => $explore_rate));
    $option_set_values = array(
      array('agent' => 'first-existing-agent', 'plugin' => 'type1', 'option_ids' => array('option-1', 'option-2')),
      array('agent' => 'first-existing-agent', 'plugin' => 'type2', 'option_ids' => array('option-a', 'option-b', 'option-c')),
    );
    foreach ($option_set_values as $i => $values) {
      $this->createOptionSet($i, $values);
    }
    // Add a goal.
    personalize_goal_save('first-existing-agent', 'new-goal', 2);
    $this->resetAll();

    // Set up some test data to be returned by the dummy http client.
    $test_data = array(
      'agents' => array(
        array('code' => 'first-existing-agent'),
      ),
      'points' => array(
        'first-existing-agent' => array(
          // The agent on the Drupal site will have this point.
          'osid-1',
          // The agent on the Drupal site will not have this point so it
          // should get deleted upon sync.
          'second-point',
        ),
      ),
      'decisions' => array(
        'first-existing-agent' => array(
          'osid-1' => array(
            'osid-1',
            // This decision should get deleted upon sync.
            'another-decision'
          )
        )
      ),
      'choices' => array(
        'first-existing-agent' => array(
          'osid-1' => array(
            'osid-1' => array(
              'option-1',
              'option-2',
              // These choices should get deleted upon sync.
              'option-3',
              'last-option'
            )
          )
        )
      ),
      'goals' => array(
        'first-existing-agent' => array(
          // This goal should get deleted upon sync.
          'first-goal'
        )
      ),
    );
    variable_set('acquia_lift_web_test_data', $test_data);

    // Now try syncing this agent to Lift.
    $agents = personalize_agent_load_multiple(array('first-existing-agent'));
    // Ensure the test API client is used during the call for operations.
    AcquiaLiftAPI::setTestInstance();
    module_load_include('inc', 'acquia_lift', 'acquia_lift.batch');
    // Confirm that the correct operations will be performed.
    $operations = acquia_lift_get_sync_operations_for_agents($agents);
    $expected_operations = array (
      array (
        'method' => 'saveAgent',
        'args' =>
          array (
            'first-existing-agent',
            'first-existing-agent',
            'adaptive',
            'enabled',
            $control_rate / 100,
            $explore_rate / 100,
            true,
          ),
      ),
      // PUT requests for all the points, decisions and choices that exist
      // in the agent being sync'd, regardless of whether they already exist
      // in Lift.
      array (
        'method' => 'savePoint',
        'args' =>
          array (
            'first-existing-agent',
            'osid-1',
          ),
      ),
      array (
        'method' => 'saveDecision',
        'args' =>
          array (
            'first-existing-agent',
            'osid-1',
            'osid-1',
          ),
      ),
      array (
        'method' => 'saveChoice',
        'args' =>
          array (
            'first-existing-agent',
            'osid-1',
            'osid-1',
            'option-1',
          ),
      ),
      array (
        'method' => 'saveChoice',
        'args' =>
          array (
            'first-existing-agent',
            'osid-1',
            'osid-1',
            'option-2',
          ),
      ),
      array (
        'method' => 'savePoint',
        'args' =>
          array (
            'first-existing-agent',
            'osid-2',
          ),
      ),
      array (
        'method' => 'saveDecision',
        'args' =>
          array (
            'first-existing-agent',
            'osid-2',
            'osid-2',
          ),
      ),

      array (
        'method' => 'saveChoice',
        'args' =>
          array (
            'first-existing-agent',
            'osid-2',
            'osid-2',
            'option-a',
          ),
      ),
      array (
        'method' => 'saveChoice',
        'args' =>
          array (
            'first-existing-agent',
            'osid-2',
            'osid-2',
            'option-b',
          ),
      ),
      array (
        'method' => 'saveChoice',
        'args' =>
          array (
            'first-existing-agent',
            'osid-2',
            'osid-2',
            'option-c',
          ),
      ),
      // DELETE request for non-existent choices.
      array (
        'method' => 'deleteChoice',
        'args' =>
          array (
            'first-existing-agent',
            'osid-1',
            'osid-1',
            'option-3',
          ),
      ),
      array (
        'method' => 'deleteChoice',
        'args' =>
          array (
            'first-existing-agent',
            'osid-1',
            'osid-1',
            'last-option',
          ),
      ),
      // DELETE request for non-existent decision.
      array (
        'method' => 'deleteDecision',
        'args' =>
          array (
            'first-existing-agent',
            'osid-1',
            'another-decision',
          ),
      ),
      // DELETE request for non-existent decision point.
      array (
        'method' => 'deletePoint',
        'args' =>
          array (
            'first-existing-agent',
            'second-point',
          ),
      ),
      // PUT request for targeting mapping for osid-1
      array (
        'method' => 'saveFixedTargetingMapping',
        'args' =>
          array (
            'first-existing-agent',
            'osid-1',
            array (),
          ),
      ),
      // PUT request for targeting mapping for osid-2
      array (
        'method' => 'saveFixedTargetingMapping',
        'args' =>
          array (
            'first-existing-agent',
            'osid-2',
            array (),
          ),
      ),
      // PUT request for the new goal
      array (
        'method' => 'saveGoal',
        'args' =>
          array (
            'first-existing-agent',
            'new-goal',
          ),
      ),
      // DELETE request for the goal that exists in Lift but not in the agent
      // being sync'd.
      array (
        'method' => 'deleteGoal',
        'args' =>
          array (
            'first-existing-agent',
            'first-goal',
          ),
      ),
    );
    $this->assertEqual($expected_operations, $operations);
  }


  public function testReadReportsFromFile() {
    $this->drupalLogin($this->managerUser);
    $first_agent = 'new-test-agent';
    $second_agent = 'second-test-agent';
    $control_rate = 10;
    $explore_rate = 30;
    $this->createTestAgent(array('name' => $first_agent, 'control_rate' => $control_rate, 'explore_rate' => $explore_rate));
    // Our second agent will continu to read reports from the API when our first switches
    // to reading from a file.
    $this->createTestAgent(array('name' => $second_agent, 'control_rate' => $control_rate, 'explore_rate' => $explore_rate));
    $test_data = array();
    // Set each agent up with an option set with 2 options, and a goal, and set it to
    // running.
    foreach (array($first_agent, $second_agent) as $i => $agent_name) {
      $this->createOptionSet($i, array('agent' => $agent_name, 'plugin' => 'type1', 'option_ids' => array('option-1', 'option-2')));
      // Add a goal.
      personalize_goal_save($agent_name, 'new-goal', 1);

      // We need to bypass the personalize_agent_set_status() function because it
      // does the verification check, which would fail.
      variable_set(_personalize_agent_get_status_variable($agent_name), PERSONALIZE_STATUS_RUNNING);
      // Set the started time of the agent to now.
      $agent = personalize_agent_load($agent_name);
      $started = time();
      $agent->started = $started;
      personalize_agent_save($agent);
      // Add some test data so that calls to get reports for this agent will
      // return basic reports.
      $test_data = array_merge_recursive($test_data, array(
        // We need to replicate this test agent on the server so that the errors()
        // check will pass.
        'agents' => array(
          array('code' => $agent_name),
        ),
        'points' => array(
          $agent_name => array(
            'osid-1',
          ),
        ),
        'decisions' => array(
          $agent_name => array(
            'osid-1' => array(
              'osid-1',
            )
          )
        ),
        'choices' => array(
          $agent_name => array(
            'osid-1' => array(
              'osid-1' => array(
                'option-1',
                'option-2',
              )
            )
          )
        ),
        'goals' => array(
          $agent_name => array(
            // This goal should get deleted upon sync.
            'new-goal'
          )
        ),
        // Now add the reports.
        'reports' => array(
          $agent_name => array(
            'confidence' => AcquiaLiftTestReports::getBasicConfidenceReport($agent_name),
            'targeting-features' => AcquiaLiftTestReports::getBasicTargetingReport($agent_name),
            'learning' => array(),
            'agent-status' => AcquiaLiftTestReports::getBasicStatusReport($agent_name),
            'context-filters' => AcquiaLiftTestReports::getBasicContextFilters()
          )
        )
      ));
    }
    variable_set('acquia_lift_web_test_data', $test_data);
    $this->resetAll();

    // We use the date that the test report was created.
    $report_start_date = 1407499650;
    AcquiaLiftAPI::setTestInstance();
    $agent_instance = personalize_agent_load_agent($first_agent);
    $report = $agent_instance->buildCampaignReports('osid-1', $report_start_date);

    // The experiment report should show that Option A was shown 0 times.
    $this->assertEqual("Control: Option A", $report['experiment']['content']['#rows'][0]['data'][1]);
    $this->assertEqual("0 times", $report['experiment']['content']['#rows'][0]['data'][2]);

    // The report for the second agent will be identical
    $agent_instance = personalize_agent_load_agent($second_agent);
    $report = $agent_instance->buildCampaignReports('osid-1', $report_start_date);
    $this->assertEqual("Control: Option A", $report['experiment']['content']['#rows'][0]['data'][1]);
    $this->assertEqual("0 times", $report['experiment']['content']['#rows'][0]['data'][2]);

    $agent_instance = NULL;
    $this->resetAll();
    // Now set the first agent to use a report from a file.
    $path = drupal_get_path('module', 'acquia_lift');
    variable_set("acquia_lift_report_source_$first_agent", "/" . $path . '/tests/test_reports.json');
    $agent_instance = personalize_agent_load_agent($first_agent);
    $report = $agent_instance->buildCampaignReports('osid-1', $report_start_date);

    // Now the experiment report should show that Option A was shown 9 times.
    $this->assertEqual("Control: Option A", $report['experiment']['content']['#rows'][0]['data'][1]);
    $this->assertEqual("9 times", $report['experiment']['content']['#rows'][0]['data'][2]);

    // The report for the second agent should still show the basic report data.
    $agent_instance = personalize_agent_load_agent($second_agent);
    $report = $agent_instance->buildCampaignReports('osid-1', $report_start_date);
    $this->assertEqual("Control: Option A", $report['experiment']['content']['#rows'][0]['data'][1]);
    $this->assertEqual("0 times", $report['experiment']['content']['#rows'][0]['data'][2]);
  }

  /**
   * Asserts that the expected items are in the queue.
   *
   * @param $expected_items
   *   An array of queued items.
   */
  protected function assertQueueItems($expected_items) {
    $actual_items = array();
    $result = db_query('SELECT data FROM {queue} q WHERE name = \'acquia_lift_sync\' ORDER BY created ASC');
    foreach ($result as $row) {
      $actual_items[] = unserialize($row->data);
    }
    $this->assertEqual($expected_items, $actual_items);
  }

  /**
   * Help function to create and test queue creation of Personalize Agent
   *
   * @param array $data
   *  array (
   *    'name' => Agent title
   *    'machine_name' => string processed by personalize_generate_machine_name()
   *  )
   * @param bool $cleanQueue Clean or not Drupal queue after 'saveAgent' queue testing
   * @return NULL|PersonalizeAgentInterface
   *
   * @see personalize_generate_machine_name()
   * @see testSaveAgent()
   */
  protected function createTestAgent($data = array(), $cleanQueue = TRUE, $assertResults = TRUE) {
    $this->configureAcquiaLiftAccount();
    $this->drupalLogin($this->managerUser);

    $data += array(
      'name' => $this->randomName(),
      'agent_type' => 'acquia_lift',
      'decision_style' => 'adaptive',
      'control_rate' => 10,
      'explore_rate' => 20,
      'cache_decisions' => 1
    );

    $data +=  array('machine_name' => personalize_generate_machine_name($data['name'], 'personalize_agent_machine_name_exists'));
    $edit = array(
      'agent_basic_info[title]' => $data['name'],
      'agent_basic_info[machine_name]' => $data['machine_name'],
      'agent_basic_info[agent_type]' => $data['agent_type'],
      'agent_basic_info[options][acquia_lift][decision_style]' => $data['decision_style'],
      'agent_basic_info[options][acquia_lift][control_rate]' => $data['control_rate'],
      'agent_basic_info[options][acquia_lift][explore_rate]' => $data['explore_rate'],
      'cache_decisions' => $data['cache_decisions']
    );

    $this->drupalPost('admin/structure/personalize/add', $edit, $this->getButton('agent'));
    $agent = personalize_agent_load_agent($data['machine_name'], TRUE);

    if ($assertResults) {
      $this->assertTrue($agent instanceof AcquiaLiftAgent);
    }

    $expected_queue_items = array(
      array(
        'method' => 'saveAgent',
        'args' => array(
          $data['machine_name'],
          $data['name'],
          'adaptive',
          'enabled',
          isset($data['control_rate']) ? $data['control_rate'] / 100 : .1,
          isset($data['explore_rate']) ? ($data['explore_rate'] / 100) : .2,
          isset($data['cache_decisions']) && $data['cache_decisions']
        )
      )
    );
    if ($assertResults) {
      $this->assertQueueItems($expected_queue_items);
    }

    if ($cleanQueue) {
      $this->personalizedQueue->deleteQueue();
    }

    return $agent;
  }

  protected function createOptionSet($index, $optionData) {
    $option_set = array(
      'plugin' => $optionData['plugin'],
      'label' => 'Option Set ' . ($index + 1),
      'agent' => $optionData['agent'],
    );
    $options = array();
    $choice_ids = array();
    if (!isset($optionData['option_ids'])) {
      for ($j = 0; $j < $optionData['num_options']; $j++) {
        $option_id = personalize_generate_option_id($j);
        $choice_ids[] = $option_id;
        $options[$j] = array(
          'option_id' => $option_id,
          'option_label' => personalize_generate_option_label($j),
        );
      }
    }
    else {
      foreach ($optionData['option_ids'] as $i => $option_id) {
        $choice_ids[] = $option_id;
        $options[$i] = array(
          'option_id' => $option_id,
          'option_label' => personalize_generate_option_label($i),
        );
      }
    }

    $option_set['options'] = $options;
    $option_set = (object) $option_set;
    personalize_option_set_save($option_set);

    $expected_queue_items[] = array(
      'method' => 'savePoint',
      'args' => array(
        $optionData['agent'],
        personalize_get_decision_point_name_for_option_set($option_set),
      )
    );
    // An item will be added to the queue to save the decision.
    $expected_queue_items[] = array(
      'method' => 'saveDecision',
      'args' => array(
        $optionData['agent'],
        personalize_get_decision_point_name_for_option_set($option_set),
        personalize_get_decision_name_for_option_set($option_set)
      )
    );
    // An item will be added to teh queue to save each option.
    foreach ($choice_ids as $choice) {
      $expected_queue_items[] = array(
        'method' => 'saveChoice',
        'args' => array(
          $optionData['agent'],
          personalize_get_decision_point_name_for_option_set($option_set),
          personalize_get_decision_name_for_option_set($option_set),
          $choice
        )
      );
    }

    return array($option_set, $expected_queue_items);
  }

  /**
   * Creates a user profile field which can be used for targeting.
   *
   * @return array
   *   An associative array representing the field.
   */
  protected function createUserProfileField() {
    $field = array(
      'field_name' => 'field_' . drupal_strtolower($this->randomName()),
      'type' => 'text',
      'cardinality' => 1,
    );

    field_create_field($field);
    $fieldInstance = array(
      'field_name' => $field['field_name'],
      'entity_type' => 'user',
      'bundle' => 'user',
      'settings' => array(
        'user_register_form' => FALSE,
      ),
    );

    field_create_instance($fieldInstance);
    return $field;
  }

  /**
   * Helper method to move buttons names to one pace to simplify
   * it's maintaining
   *
   * Kind of Page Objects Patterns
   *
   * @param $type string
   * @return string
   */
  protected function getButton($type = '') {
    switch ($type) {
      case 'agent':
        return t('Save campaign settings');
      case 'goal':
        return t('Save goals');
      case 'option':
        return t('Save variation sets');
      case 'mvt':
        return t('Save test');
      case 'delete':
        return t('Delete');
      case 'config':
        return t('Save configuration');
      default:
        return t('Save');
    }
  }

  /**
   * Helper method to configure an Acquia Lift account.
   */
  protected function configureAcquiaLiftAccount() {
    $edit = array(
      'acquia_lift_account_info[owner_code]' => $this->liftAOwnerCode,
      'acquia_lift_account_info[api_key]' => $this->liftAPIKey,
      'acquia_lift_account_info[admin_key]' => $this->liftAdminKey,
      'acquia_lift_account_info[api_url]' => $this->liftAPIUrl,
    );
    $this->drupalLogin($this->adminUser);
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));

    $this->resetAll();
  }
}
