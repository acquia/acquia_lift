<?php

/**
 * @file
 * Integration tests for Acquia Lift module.
 */

class AcquiaLiftWebTestBase extends DrupalWebTestCase
{
  /**
   * The string to use as the runtime API key.
   *
   * @var string
   */
  protected $liftAPIKey = 'api-key-123';

  /**
   * The string to use as the admin API key.
   *
   * @var string
   */
  protected $liftAdminKey = 'admin-key-123';

  /**
   * The string to use as the admin API URL.
   *
   * @var string
   */
  protected $liftAPIUrl = 'http://some.valid.url';

  /**
   * The string to use as the owner code.
   *
   * @var string
   */
  protected $liftAOwnerCode = 'Some_valid-owner123-code';

  protected $adminUser;

  protected $managerUser;

  public function setUp()
  {
    require_once(dirname(__FILE__) . '/../includes/acquia_lift.classes.inc');
    require_once(dirname(__FILE__) . '/acquia_lift.test_classes.inc');

    parent::setUp(array('ctools', 'personalize', 'acquia_lift', 'personalize_blocks', 'personalize_test'));

    $this->adminUser = $this->drupalCreateUser(array('access administration pages', 'administer personalize configuration'));

    $this->managerUser = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer visitor actions'));
    $this->drupalLogin($this->managerUser);

    variable_set('acquia_lift_account_info', array(
      'owner_code' => $this->liftAOwnerCode,
      'api_key' => $this->liftAPIKey,
      'admin_key' => $this->liftAdminKey,
    ));
  }

  public function tearDown()
  {
    variable_del('acquia_lift_web_test_data');
    parent::tearDown();
  }

  /**
   * Helper function to create an agent.
   */
  protected function createTestAgent($label = NULL, $options = array(), $type = 'test_agent') {
    if ($type == 'acquia_lift') {
      $this->configureAcquiaLiftAccount();
      $options += array(
        'decision_style' => 'adaptive',
        'control_rate' => 10,
        'explore_rate' => 20,
        'cache_decisions' => 1,
        'auto_stop' => 0
      );
    }

    if (empty($label)) {
      $label = $this->randomName();
    }
    $agent = new stdClass();
    $agent->label = $label;
    $agent->plugin = $type;
    $agent->data = $options;
    $agent->machine_name = personalize_generate_machine_name($label, 'personalize_agent_machine_name_exists');
    $agent = personalize_agent_save($agent);
    $this->resetAll();
    $agent_instance = personalize_agent_load_agent($agent->machine_name, TRUE);
    return $agent_instance;
  }

  /**
   * A helper function to create an acquia_lift_target agent.
   * @param string $label
   *   (Optional) The label for the new agent.
   * @return stdClass
   *   The newly created agent data.
   */
  protected function createTargetingAgent($label = NULL) {
    if (empty($label)) {
      $label = $this->randomName();
    }
    $agent = new stdClass();
    $agent->label = $label;
    $agent->plugin = 'acquia_lift_target';
    $agent->data = array();
    $agent->machine_name = personalize_generate_machine_name($label, 'personalize_agent_machine_name_exists');
    $agent = personalize_agent_save($agent);
    $this->resetAll();
    $this->resetAll();
    return $agent;
  }

  protected function createOptionSet($index, $optionData) {
    $option_set = array(
      'plugin' => $optionData['plugin'],
      'label' => 'Option Set ' . ($index + 1),
      'agent' => $optionData['agent'],
    );
    $options = array();
    $choice_ids = array();
    if (!isset($optionData['option_ids'])) {
      for ($j = 0; $j < $optionData['num_options']; $j++) {
        $option_id = personalize_generate_option_id($j);
        $choice_ids[] = $option_id;
        $options[$j] = array(
          'option_id' => $option_id,
          'option_label' => personalize_generate_option_label($j),
        );
      }
    }
    else {
      foreach ($optionData['option_ids'] as $i => $option_id) {
        $choice_ids[] = $option_id;
        $options[$i] = array(
          'option_id' => $option_id,
          'option_label' => personalize_generate_option_label($i),
        );
      }
    }

    $option_set['options'] = $options;
    $option_set = (object) $option_set;
    try {
      personalize_option_set_save($option_set);
    }
    catch (PersonalizeException $e) {
      $this->fail('Exception thrown with message: . ' . $e->getMessage());
    }

    return $option_set;
  }

  /**
   * Creates a user profile field which can be used for targeting.
   *
   * @return array
   *   An associative array representing the field.
   */
  protected function createUserProfileField() {
    $field = array(
      'field_name' => 'field_' . drupal_strtolower($this->randomName()),
      'type' => 'text',
      'cardinality' => 1,
    );

    field_create_field($field);
    $fieldInstance = array(
      'field_name' => $field['field_name'],
      'entity_type' => 'user',
      'bundle' => 'user',
      'settings' => array(
        'user_register_form' => FALSE,
      ),
    );

    field_create_instance($fieldInstance);
    return $field;
  }

  /**
   * Helper method to move buttons names to one pace to simplify
   * it's maintaining
   *
   * Kind of Page Objects Patterns
   *
   * @param $type string
   * @return string
   */
  protected function getButton($type = '') {
    switch ($type) {
      case 'wizard_next':
        return t('Next');
      case 'wizard_save':
      case 'wizard_done':
        return t('Save');
      case 'wizard_start':
        return t('Start');
      case 'wizard_element_navigate':
        return t('Go');
      case 'create_campaign':
        return t('Create personalization');
      case 'delete':
        return t('Delete');
      case 'config':
        return t('Save configuration');
      default:
        return t('Save');
    }
  }

  /**
   * Helper method to configure an Acquia Lift account.
   */
  protected function configureAcquiaLiftAccount() {
    $edit = array(
      'acquia_lift_account_info[owner_code]' => $this->liftAOwnerCode,
      'acquia_lift_account_info[api_key]' => $this->liftAPIKey,
      'acquia_lift_account_info[admin_key]' => $this->liftAdminKey,
      'acquia_lift_account_info[api_url]' => $this->liftAPIUrl,
    );
    $this->drupalLogin($this->adminUser);
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));

    $this->resetAll();
  }

  /**
   * Creates the required number of custom blocks.
   *
   * @param int $num
   *   The number of blocks to create.
   *
   * @return array
   *   An array of block deltas for use in personalized blocks.
   */
  protected function createPersonalizedBlock($index, $agent, $num_options = 2) {
    $option_set = array(
      'plugin' => 'block',
      'label' => 'Option Set ' . ($index + 1),
      'agent' => $agent->machine_name,
      'data' => array(
        'block_title' => 'Personalized Block ' . ($index + 1)
      )
    );
    $options = array();
    module_load_include('inc', 'personalize_blocks', 'personalize_blocks.admin');
    for ($i = 1; $i <= $num_options; $i++) {
      $title = t('Custom block @num', array('@num' => $i));
      $values = array(
        'title' => $title,
        'info' => $title,
        'body' => array(
          'format' => 'filtered_html',
          'value' => 'Some value',
        )
      );
      $option = array(
        'option_label' => 'Option ' . ($i),
        'option_id' => 'option-' . $i,
        'bid' => _personalize_blocks_add_custom_block($values)
      );
      $options[] = $option;
    }
    $option_set['options'] = $options;
    $option_set = (object) $option_set;
    try {
      personalize_option_set_save($option_set);
    }
    catch (PersonalizeException $e) {
      $this->fail('Exception thrown with message: . ' . $e->getMessage());
      return NULL;
    }
    return $option_set;
  }
}

class AcquiaLiftWebTestConfig extends AcquiaLiftWebTestBase {

  public static function getInfo() {
    return array(
      'name' => t('Acquia Lift Web Tests - Configuration'),
      'description' => t('Tests related to configuring Acquia Lift.'),
      'group' => t('Personalize'),
    );
  }

  public function testLiftAgentAvailibility() {
    // remove the account information
    $lift_info = variable_get('acquia_lift_account_info', array());
    variable_del('acquia_lift_account_info');
    $this->resetAll();

    // Try to add a new campaign and verify that the Acquia Lift agent isn't presented.
    $this->drupalGet('admin/structure/personalize/add');
    $this->assertText(t('Your Acquia Lift account info has not been configured.'));

    // Add the configuration information for the Lift account.
    $this->configureAcquiaLiftAccount();

    $this->drupalLogin($this->managerUser);

    // Now confirm that Acquia Lift is an option for new campaigns.
    $this->drupalGet('admin/structure/personalize/add');
    $this->assertNoText(t('Your Acquia Lift account info has not been configured.'));
  }


  public function testConfigForm() {
    $this->drupalLogin($this->adminUser);
    // Try entering an invalid owner code.
    $edit = array(
      'acquia_lift_account_info[owner_code]' => 'some invalid string',
      'acquia_lift_account_info[api_key]' => $this->liftAPIKey,
      'acquia_lift_account_info[admin_key]' => $this->liftAdminKey,
      'acquia_lift_account_info[api_url]' => $this->liftAPIUrl,
    );
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertText('You must enter a valid owner code');

    // Now try with a valid code.
    $edit['acquia_lift_account_info[owner_code]'] = $this->liftAOwnerCode;
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertNoText('You must enter a valid owner code');
    $account_info = variable_get('acquia_lift_account_info', array());
    $this->assertEqual($account_info['owner_code'], $this->liftAOwnerCode);
    $this->assertEqual($account_info['api_key'], $this->liftAPIKey);
    $this->assertEqual($account_info['admin_key'], $this->liftAdminKey);
    $this->assertEqual($account_info['api_url'], 'some.valid.url');
    // Try entering an invalid API url.
    $edit['acquia_lift_account_info[api_url]'] = 'some\\invalid\\url';
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertText('You must enter a valid URL');
    // Try a valid URL with no scheme.
    $edit['acquia_lift_account_info[api_url]'] = 'some.valid.url';
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertNoText('You must enter a valid URL');
    // Try a valid URL with scheme.
    $edit['acquia_lift_account_info[api_url]'] = 'https://some.valid.url';
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertNoText('You must enter a valid URL');
    $this->resetAll();
    $account_info = variable_get('acquia_lift_account_info', array());
    // The scheme should have been stripped out before saving.
    $this->assertEqual($account_info['api_url'], 'some.valid.url');

    // Submit bogus confidence measures.
    $bad_measures = array(
      'abcd' => t('Confidence measure must be a number.'),
      145 => t('Confidence measure must be a value between 0 and 100.'),
      -45 => t('Confidence measure must be a value between 0 and 100.'),
    );
    foreach ($bad_measures as $measure => $message) {
      $edit['acquia_lift_confidence_measure'] = $measure;
      $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
      $this->assertText($message);
      $this->assertNoText(t('A minimum confidence measure of 80% is recommended to ensure proper evaluation of test results.'));
      $this->assertNoText(t('The configuration options have been saved.'));
    }

    // Submit a low confidence measure and test warning.
    $edit['acquia_lift_confidence_measure'] = '10';
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertText(t('A minimum confidence measure of 95% is recommended to ensure proper evaluation of test results.'));
    $this->assertText(t('The configuration options have been saved.'));

    // Submit a valid measure and confirm it is saved without warning.
    $edit['acquia_lift_confidence_measure'] = '95';
    $this->drupalPost('admin/config/content/personalize/acquia_lift', $edit, $this->getButton('config'));
    $this->assertNoText(t('A minimum confidence measure of 95% is recommended to ensure proper evaluation of test results.'));
    $this->assertText(t('The configuration options have been saved.'));
  }

  function testPersonalizeElementsConfigurationIntegration() {
    $fullAdminUser = $this->drupalCreateUser(array('access administration pages', 'administer personalize configuration', 'use advanced personalize elements features'));
    $this->drupalLogin($fullAdminUser);

    // Test edit in context settings added to personalize elements configuration form.
    $this->drupalGet('admin/config/content/personalize/personalize-elements');
    // Should be initially set to 1.
    $this->assertFieldChecked('edit-acquia-lift-html-context-strip');
    $edit = array(
      'acquia_lift_html_context_strip' => FALSE,
    );
    $this->drupalPost(NULL, $edit, $this->getButton('config'));

    // Check the javascript setting.
    $this->drupalLogin($this->managerUser);
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $this->assertEqual($settings['acquia_lift']['edit_in_context_html_strip'], 0);

    // Set it back.
    $this->drupalLogin($fullAdminUser);
    $edit = array(
      'acquia_lift_html_context_strip' => TRUE,
    );
    $this->drupalPost('admin/config/content/personalize/personalize-elements', $edit, $this->getButton('config'));

    // Check that the JavaScript settings changed.
    $this->drupalLogin($this->managerUser);
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $this->assertEqual($settings['acquia_lift']['edit_in_context_html_strip'], 1);
  }
}
class AcquiaLiftWebTestVariationSets extends AcquiaLiftWebTestBase {

  public static function getInfo() {
    return array(
      'name' => t('Acquia Lift Web Tests - Variation Sets'),
      'description' => t('Tests functionality related to variation set creation.'),
      'group' => t('Personalize'),
    );
  }

  function testPersonalizeBlockRedirection() {
    // Create a new agent
    $agent = $this->createTestAgent();

    // Create a personalized block from the form with a destination in the
    // url query string.
    $this->drupalGet('/admin/structure/personalize/variations/personalize-blocks/add', array('query' => array('destination' => 'node')));
    $edit = array(
      'agent_select' => $agent->getMachineName(),
      'title' => 'My test block',
      'blocks[0][option_label]' =>  'Option A',
      'blocks[0][block][bid]' => 'comment_delta_recent',
      'blocks[1][option_label]' =>  'Option B',
      'blocks[1][block][bid]' => 'system_delta_main',
    );
    $this->drupalPost(NULL, $edit, t('Save'));

    // Verify that the user is redirected to the original page with a custom
    // URL query parameter.
    $this->assertUrl('node', array('query' => array('liftpm' => 'new_block|My test block')));

    // Verify that the pending message has been added to the settings.
    $expected_message = t('Created the new <em class="placeholder">My test block</em> personalized block. The block will not appear on your website until you add the block to a region on the !blocks page.', array(
      '!blocks' => l('Structure > Blocks', 'admin/structure/blocks'),
    ));
    $settings = $this->drupalGetSettings();
    $this->assertEqual($settings['acquia_lift']['pendingMessage'], array($expected_message));
  }
}

class AcquiaLiftWebTestAgentAdmin extends AcquiaLiftWebTestBase {
  public static function getInfo() {
    return array(
      'name' => t('Acquia Lift Web Tests - Agent Administration'),
      'description' => t('Tests functionality of adminstering Acquia Lift agents and their components.'),
      'group' => t('Personalize'),
    );
  }

  /**
   * Tests that agents are paused when they need to be paused.
   */
  function testPauseAgents() {

  }
}

class AcquiaLiftWebTestFundamentals extends AcquiaLiftWebTestBase {
  public static function getInfo() {
    return array(
      'name' => t('Acquia Lift Web Tests - Fundamentals'),
      'description' => t('Tests the module\'s underlying machinery.'),
      'group' => t('Personalize'),
    );
  }

  /**
   * Tests the logic in AcquiaLiftAgent's implementation of convertContextToFeatureString().
   */
  public function testConvertContextToFeatureString()
  {
    ctools_include('plugins');
    // Make sure the AcquiaLiftAgent class is available.
    if (!$agent_class = ctools_plugin_load_class('personalize', 'agent_type', 'acquia_lift', 'handler')) {
      return;
    }
    //ctools_plugin_load_class('personalize', 'agent_type', 'acquia_lift', 'handler');
    // No truncation should happen if name and value are short enough.
    $name = $this->randomName(20);
    $value = $this->randomName(20);
    $string = AcquiaLiftAgent::convertContextToFeatureString($name, $value);
    $expected = $name . '::' . $value;
    $this->assertEqual($expected, $string);
    $string = AcquiaLiftAgent::convertContextToFeatureString($name, $value, TRUE);
    $expected = $name . ':' . $value;
    $this->assertEqual($expected, $string);
    // If we have a really long name and value test that they are truncated
    // correctly.
    $long_name = $this->randomName(40);
    $long_value = $this->randomName(40);
    $string = AcquiaLiftAgent::convertContextToFeatureString($long_name, $long_value);
    $expected = substr($long_name, 0, 24) . '::' . substr($long_value, 0, 24);
    $this->assertEqual($expected, $string);
    $string = AcquiaLiftAgent::convertContextToFeatureString($long_name, $long_value, TRUE);
    $expected = substr($long_name, 0, 24) . ':' . substr($long_value, 0, 25);
    $this->assertEqual($expected, $string);
  }


  /**
   * Tests that new agents on the site cannot override existing agents in Lift.
   */
  public function testMachineNameValidation()
  {
    $test_data = array(
      'agents' => array(
        array('code' => 'my-existing-agent'),
      ),
    );
    variable_set('acquia_lift_web_test_data', $test_data);
    AcquiaLiftAPI::setTestInstance();
    // Try to create a new agent with the same name as one that exists in Lift.
    $this->createTestAgent('my-existing-agent', array('control_rate' => 10, 'explore_rate' => 30), 'acquia_lift');
    $this->resetAll();
    $agent = personalize_agent_load_agent('my-existing-agent');
    $this->assertNull($agent);
    $agent = personalize_agent_load_agent('my-existing-agent-0');
    $this->assertTrue($agent instanceof AcquiaLiftAgentInterface);
  }

  /**
   * Tests the function that gathers operations for syncing of agents and their
   * components to Lift.
   */
  public function testBatchSyncOperations()
  {
    // Create an agent on the site with a couple of option sets.
    // Note: we do this part first rather than loading the test data to
    // the server because otherwise it wouldn't allow us to create an
    // agent with the same name as an existing one.
    $control_rate = 10;
    $explore_rate = 30;
    $options = array(
      'control_rate' => $control_rate,
      'explore_rate' => $explore_rate
    );
    $this->createTestAgent('first-existing-agent', $options, 'acquia_lift');
    $option_set_values = array(
      array(
        'agent' => 'first-existing-agent',
        'plugin' => 'type1',
        'option_ids' => array('option-1', 'option-2')
      ),
      array(
        'agent' => 'first-existing-agent',
        'plugin' => 'type2',
        'option_ids' => array('option-a', 'option-b', 'option-c')
      ),
    );
    $option_sets = array();
    foreach ($option_set_values as $i => $values) {
      $option_set = $this->createOptionSet($i, $values);
      $option_sets[] = $option_set;
    }
    $first_osid = 'osid-' . $option_sets[0]->osid;
    $second_osid = 'osid-' . $option_sets[1]->osid;
    // Add a goal.
    personalize_goal_save('first-existing-agent', 'new-goal', 2);
    $this->resetAll();

    // Set up some test data to be returned by the dummy http client.
    $test_data = array(
      'agents' => array(
        array('code' => 'first-existing-agent'),
      ),
      'points' => array(
        'first-existing-agent' => array(
          // The agent on the Drupal site will have this point.
          $first_osid,
          // The agent on the Drupal site will not have this point so it
          // should get deleted upon sync.
          'second-point',
        ),
      ),
      'decisions' => array(
        'first-existing-agent' => array(
          $first_osid => array(
            $first_osid,
            // This decision should get deleted upon sync.
            'another-decision'
          )
        )
      ),
      'choices' => array(
        'first-existing-agent' => array(
          $first_osid => array(
            $first_osid => array(
              'option-1',
              'option-2',
              // These choices should get deleted upon sync.
              'option-3',
              'last-option'
            )
          )
        )
      ),
      'goals' => array(
        'first-existing-agent' => array(
          // This goal should get deleted upon sync.
          'first-goal'
        )
      ),
    );
    variable_set('acquia_lift_web_test_data', $test_data);

    // Now try syncing this agent to Lift.
    $agents = personalize_agent_load_multiple(array('first-existing-agent'));
    // Ensure the test API client is used during the call for operations.
    AcquiaLiftAPI::setTestInstance();
    module_load_include('inc', 'acquia_lift', 'acquia_lift.batch');
    // Confirm that the correct operations will be performed.
    $operations = acquia_lift_get_sync_operations_for_agents($agents);
    $expected_operations = array(
      array(
        'method' => 'saveAgent',
        'args' =>
          array(
            'first-existing-agent',
            'first-existing-agent',
            'adaptive',
            PERSONALIZE_STATUS_NOT_STARTED,
            $control_rate / 100,
            $explore_rate / 100,
            TRUE,
          ),
      ),
      // PUT requests for all the points, decisions and choices that exist
      // in the agent being sync'd, regardless of whether they already exist
      // in Lift.
      array(
        'method' => 'savePoint',
        'args' =>
          array(
            'first-existing-agent',
            $first_osid,
          ),
      ),
      array(
        'method' => 'saveDecision',
        'args' =>
          array(
            'first-existing-agent',
            $first_osid,
            $first_osid,
          ),
      ),
      array(
        'method' => 'saveChoice',
        'args' =>
          array(
            'first-existing-agent',
            $first_osid,
            $first_osid,
            'option-1',
          ),
      ),
      array(
        'method' => 'saveChoice',
        'args' =>
          array(
            'first-existing-agent',
            $first_osid,
            $first_osid,
            'option-2',
          ),
      ),
      array(
        'method' => 'savePoint',
        'args' =>
          array(
            'first-existing-agent',
            $second_osid,
          ),
      ),
      array(
        'method' => 'saveDecision',
        'args' =>
          array(
            'first-existing-agent',
            $second_osid,
            $second_osid,
          ),
      ),
      array(
        'method' => 'saveChoice',
        'args' =>
          array(
            'first-existing-agent',
            $second_osid,
            $second_osid,
            'option-a',
          ),
      ),
      array(
        'method' => 'saveChoice',
        'args' =>
          array(
            'first-existing-agent',
            $second_osid,
            $second_osid,
            'option-b',
          ),
      ),
      array(
        'method' => 'saveChoice',
        'args' =>
          array(
            'first-existing-agent',
            $second_osid,
            $second_osid,
            'option-c',
          ),
      ),
      // DELETE request for non-existent choices.
      array(
        'method' => 'deleteChoice',
        'args' =>
          array(
            'first-existing-agent',
            $first_osid,
            $first_osid,
            'option-3',
          ),
      ),
      array(
        'method' => 'deleteChoice',
        'args' =>
          array(
            'first-existing-agent',
            $first_osid,
            $first_osid,
            'last-option',
          ),
      ),
      // DELETE request for non-existent decision.
      array(
        'method' => 'deleteDecision',
        'args' =>
          array(
            'first-existing-agent',
            $first_osid,
            'another-decision',
          ),
      ),
      // DELETE request for non-existent decision point.
      array(
        'method' => 'deletePoint',
        'args' =>
          array(
            'first-existing-agent',
            'second-point',
          ),
      ),
      // PUT request for the new goal
      array(
        'method' => 'saveGoal',
        'args' =>
          array(
            'first-existing-agent',
            'new-goal',
          ),
      ),
      // DELETE request for the goal that exists in Lift but not in the agent
      // being sync'd.
      array(
        'method' => 'deleteGoal',
        'args' =>
          array(
            'first-existing-agent',
            'first-goal',
          ),
      ),
    );
    $this->assertEqual($expected_operations, $operations);
  }
}

class AcquiaLiftWebTestReports extends AcquiaLiftWebTestBase {
  public static function getInfo() {
    return array(
      'name' => t('Acquia Lift Web Tests - Reporting'),
      'description' => t('Tests the reporting functionality for Acquia Lift.'),
      'group' => t('Personalize'),
    );
  }

  public function testConversionReportAjaxEndpoint() {
    $agent = $this->createTestAgent(NULL, array(), 'acquia_lift');
    $agent_name = $agent->getMachineName();
    $this->drupalLogin($this->managerUser);
    // Set the agent to read report data from the test file.
    $path = drupal_get_path('module', 'acquia_lift');
    variable_set("acquia_lift_report_source_" . $agent_name, "/" . $path . '/tests/test_reports.json');

    // Call the conversion report endpoint.
    $first_osid = 'osid-1';
    $report = $this->drupalGet('acquia_lift/reports/conversion', array('query' => array(
      'campaign' => $agent_name,
      'decision' => $first_osid,
    )));

    $report = drupal_json_decode($report);

    $pattern = '/class="lift-statistic-category"/';
    preg_match($pattern, $report, $matches);
    $this->assertEqual(count($matches), 1, 'Only one category of results returned.');

    $pattern = '/(<table)/';
    preg_match($pattern, $report, $matches);
    $this->assertEqual(count($matches), 2, 'Only two tables returned.');

    $pattern = '/data-acquia-lift-campaign=\"([a-z0-9\_\-]+)\"/';
    preg_match($pattern, $report, $matches);

    $this->assertEqual($matches[1], $agent_name, 'Personalization name was passed in tabular data.');

    $pattern = '/data-acquia-lift-decision-name=\"([a-z0-9\_\-]+)\"/';
    preg_match($pattern, $report, $matches);
    $this->assertEqual($matches[1], $first_osid, 'Decision name was passed in tabular data.');
  }

  public function testReadReportsFromFile() {
    $this->drupalLogin($this->managerUser);
    $first_agent = 'new-test-agent';
    $second_agent = 'second-test-agent';
    $control_rate = 10;
    $explore_rate = 30;
    $this->createTestAgent($first_agent, array('control_rate' => $control_rate, 'explore_rate' => $explore_rate), 'acquia_lift');
    // Our second agent will continue to read reports from the API when our first switches
    // to reading from a file.
    $this->createTestAgent($second_agent, array('control_rate' => $control_rate, 'explore_rate' => $explore_rate), 'acquia_lift');
    $test_data = array();
    // Set each agent up with an option set with 2 options, and a goal, and set it to
    // running.
    $option_sets = array();
    foreach (array($first_agent, $second_agent) as $i => $agent_name) {
      $option_set = $this->createOptionSet($i, array('agent' => $agent_name, 'plugin' => 'type1', 'option_ids' => array('option-1', 'option-2')));
      $option_sets[] = $option_set;
      $osid = $option_set->osid;
      // Add a goal.
      personalize_goal_save($agent_name, 'new-goal', 1);

      // We need to bypass the personalize_agent_set_status() function because it
      // does the verification check, which would fail.
      variable_set(_personalize_agent_get_status_variable($agent_name), PERSONALIZE_STATUS_RUNNING);
      // Set the started time of the agent to now.
      $agent = personalize_agent_load($agent_name);
      $started = time();
      $agent->started = $started;
      personalize_agent_save($agent);

      $report_start_date = 1407499650;
      // Test to ensure that an initial report at this point returns no data.
      AcquiaLiftAPI::setTestInstance();
      $agent_instance = personalize_agent_load_agent($first_agent);
      $report = $agent_instance->buildCampaignReports(array('decision' => 'osid-' . $option_sets[0]->osid, 'start' => $report_start_date));
      $this->assertFalse($report['#has_data'], 'Report has no data.');

      // Add some test data so that calls to get reports for this agent will
      // return basic reports.
      $test_data = array_merge_recursive($test_data, array(
        // We need to replicate this test agent on the server so that the errors()
        // check will pass.
        'agents' => array(
          array('code' => $agent_name),
        ),
        'points' => array(
          $agent_name => array(
            $osid,
          ),
        ),
        'decisions' => array(
          $agent_name => array(
            $osid => array(
              $osid,
            )
          )
        ),
        'choices' => array(
          $agent_name => array(
            $osid => array(
              $osid => array(
                'option-1',
                'option-2',
              )
            )
          )
        ),
        'goals' => array(
          $agent_name => array(
            // This goal should get deleted upon sync.
            'new-goal'
          )
        ),
        // Now add the reports.
        'reports' => array(
          $agent_name => array(
            'confidence' => AcquiaLiftTestReports::getBasicConfidenceReport($agent_name),
            'targeting-features' => AcquiaLiftTestReports::getBasicTargetingReport($agent_name),
            'learning' => array(),
            'agent-status' => AcquiaLiftTestReports::getBasicStatusReport($agent_name),
            'context-filters' => AcquiaLiftTestReports::getBasicContextFilters()
          )
        )
      ));
    }
    variable_set('acquia_lift_web_test_data', $test_data);
    $this->resetAll();
    AcquiaLiftAPI::setTestInstance();
    $agent_instance = personalize_agent_load_agent($first_agent);

    // We use the date that the test report was created.
    $report = $agent_instance->buildCampaignReports(array('decision' => 'osid-' . $option_sets[0]->osid, 'start' => $report_start_date));
    $this->assertFalse($report['#has_data'], 'Empty reports have no data to show.');

    // The experiment report should show that Option A has a 0% conversion rate.
    $this->assertEqual("Option A", $report['experiment']['reports']['conversion']['reports']['summary']['summary_holder']['summary_table']['#rows'][0]['data'][0]['data']);
    $this->assertEqual("Control", $report['experiment']['reports']['conversion']['reports']['summary']['summary_holder']['summary_table']['#rows'][0]['data'][0]['data-acquia-lift-variation-label']);
    $this->assertEqual("0%", $report['experiment']['reports']['conversion']['reports']['summary']['summary_holder']['summary_table']['#rows'][0]['data'][2]['data']);

    // The report for the second agent will be identical
    $agent_instance = personalize_agent_load_agent($second_agent);
    $report = $agent_instance->buildCampaignReports(array('decision' => 'osid-' . $option_sets[0]->osid, 'start' => $report_start_date));
    $this->assertEqual("Option A", $report['experiment']['reports']['conversion']['reports']['summary']['summary_holder']['summary_table']['#rows'][0]['data'][0]['data']);
    $this->assertEqual("Control", $report['experiment']['reports']['conversion']['reports']['summary']['summary_holder']['summary_table']['#rows'][0]['data'][0]['data-acquia-lift-variation-label']);
    $this->assertEqual("0%", $report['experiment']['reports']['conversion']['reports']['summary']['summary_holder']['summary_table']['#rows'][0]['data'][2]['data']);

    $agent_instance = NULL;
    $this->resetAll();
    // Now set the first agent to use a report from a file.
    $path = drupal_get_path('module', 'acquia_lift');
    variable_set("acquia_lift_report_source_$first_agent", "/" . $path . '/tests/test_reports.json');
    $agent_instance = personalize_agent_load_agent($first_agent);
    $report = $agent_instance->buildCampaignReports(array('decision' => 'osid-' . $option_sets[0]->osid, 'start' => $report_start_date));
    $this->assertTrue($report['#has_data'], 'Report data file indicates data to show.');

    // Now the experiment report should show that Option A has a conversion rate of .19%
    $this->assertEqual("osid-76:Option A", $report['experiment']['reports']['conversion']['reports']['summary']['summary_holder']['summary_table']['#rows'][0]['data'][0]['data']);
    $this->assertEqual("Control", $report['experiment']['reports']['conversion']['reports']['summary']['summary_holder']['summary_table']['#rows'][0]['data'][0]['data-acquia-lift-variation-label']);
    $this->assertEqual("0.19%", $report['experiment']['reports']['conversion']['reports']['summary']['summary_holder']['summary_table']['#rows'][0]['data'][2]['data']);

    // The report for the second agent should still show the basic report data.
    $agent_instance = personalize_agent_load_agent($second_agent);
    $report = $agent_instance->buildCampaignReports(array('decision' => 'osid-' . $option_sets[0]->osid, 'start' => $report_start_date));
    $this->assertFalse($report['#has_data'], 'Empty report data still indicates no data to show.');
    $this->assertEqual("Option A", $report['experiment']['reports']['conversion']['reports']['summary']['summary_holder']['summary_table']['#rows'][0]['data'][0]['data']);
    $this->assertEqual("Control", $report['experiment']['reports']['conversion']['reports']['summary']['summary_holder']['summary_table']['#rows'][0]['data'][0]['data-acquia-lift-variation-label']);
    $this->assertEqual("0%", $report['experiment']['reports']['conversion']['reports']['summary']['summary_holder']['summary_table']['#rows'][0]['data'][2]['data']);
  }

  function testReportEndDate() {
    $this->drupalLogin($this->managerUser);
    module_load_include('inc', 'acquia_lift', 'acquia_lift.admin');
    $agent_label = 'new-test-agent';
    $control_rate = 10;
    $explore_rate = 30;
    $agent = $this->createTestAgent($agent_label, array('control_rate' => $control_rate, 'explore_rate' => $explore_rate), 'acquia_lift');
    $agent_name = $agent->getMachineName();

    // Set the agent up with an option set with 2 options, and a goal, and set it to
    // running.
    $option_set = $this->createOptionSet(0, array('agent' => $agent_name, 'plugin' => 'type1', 'option_ids' => array('option-1', 'option-2')));
    $osid = $option_set->osid;
    // Add a goal.
    personalize_goal_save($agent_name, 'new-goal', 1);

    // We need to bypass the personalize_agent_set_status() function because it
    // does the verification check, which would fail.
    variable_set(_personalize_agent_get_status_variable($agent_name), PERSONALIZE_STATUS_RUNNING);
    // Set the started time of the agent to 48 hours ago.
    $agent = personalize_agent_load($agent_name);
    $started = time() - (48 * 60 * 60);
    $agent->started = $started;
    personalize_agent_save($agent);
    // We need to replicate this test agent on the server so that the errors()
    // check will pass.
    $test_data = array(
      'agents' => array(
        array('code' => $agent_name),
      ),
      'points' => array(
        $agent_name => array(
          $osid,
        ),
      ),
      'decisions' => array(
        $agent_name => array(
          $osid => array(
            $osid,
          )
        )
      ),
      'choices' => array(
        $agent_name => array(
          $osid => array(
            $osid => array(
              'option-1',
              'option-2',
            )
          )
        )
      ),
      'goals' => array(
        $agent_name => array(
          // This goal should get deleted upon sync.
          'new-goal'
        )
      ),
      'reports' => array(
        $agent_name => array(
          'confidence' => AcquiaLiftTestReports::getBasicConfidenceReport($agent_name),
          'targeting-features' => AcquiaLiftTestReports::getBasicTargetingReport($agent_name),
          'learning' => array(),
          'agent-status' => AcquiaLiftTestReports::getBasicStatusReport($agent_name),
          'context-filters' => AcquiaLiftTestReports::getBasicContextFilters()
        )
      )
    );
    variable_set('acquia_lift_web_test_data', $test_data);
    $this->resetAll();
    DummyAcquiaLiftHttpClient::clearLoggedRequests();

    AcquiaLiftAPI::setTestInstance();
    $agent_instance = personalize_agent_load_agent($agent_name);
    $form_state = array();
    $agent_data = personalize_agent_load($agent_name);

    // We call the report generating function and then check the request made to the
    // Lift API.
    acquia_lift_report_custom(array(), $form_state, $agent_instance, $agent_data, $option_set);
    $requests = DummyAcquiaLiftHttpClient::getLoggedRequests();
    $start_date = date('Y-m-d', $started);
    $now = time();
    $end_date = date('Y-m-d', $now);
    $confidence_report_uri = $requests[0]['uri'];
    $pattern = "/http\:\/\/api\.example\.com\/test\-owner\-code\/{$agent_name}\/report\/confidence\/{$start_date}\/(\d{4}\-\d{2}\-\d{2})/";
    $matches = array();
    preg_match($pattern, $confidence_report_uri, $matches);
    $this->assertEqual($end_date, $matches[1]);

    // Now set the campaign to completed
    personalize_agent_set_status($agent_name, PERSONALIZE_STATUS_COMPLETED);
    // Specify the completed time as yesterday.
    $yesterday = $now - (24 * 60 * 60);
    personalize_agent_set_stop_date($agent_name, $yesterday);
    $this->resetAll();

    // Clear the logged requests.
    DummyAcquiaLiftHttpClient::clearLoggedRequests();
    // Again call the report generating function and then check the request made to the
    // Lift API. The end date should be different
    acquia_lift_report_custom(array(), $form_state, $agent_instance, $agent_data, $option_set);
    $requests = DummyAcquiaLiftHttpClient::getLoggedRequests();
    $start_date = date('Y-m-d', $started);
    $confidence_report_uri = $requests[0]['uri'];
    $pattern = "/http\:\/\/api\.example\.com\/test\-owner\-code\/{$agent_name}\/report\/confidence\/{$start_date}\/(\d{4}\-\d{2}\-\d{2})/";
    $matches = array();
    preg_match($pattern, $confidence_report_uri, $matches);
    $this->assertEqual(date('Y-m-d', $yesterday), $matches[1]);
  }
}

class AcquiaLiftWebTestWorkflow extends AcquiaLiftWebTestBase {
  public static function getInfo() {
    return array(
      'name' => t('Acquia Lift Web Tests - Workflows'),
      'description' => t('Tests functionality related to particular personalization workflows.'),
      'group' => t('Personalize'),
    );
  }
  /**
   * Tests automatic creation of a goal for personalized fields and auto-
   * starting of the campaign.
   */
  public function testPersonalizeFieldsAutoCreateGoal() {
    $this->resetAll();
    module_enable(array('personalize_fields'));
    $this->resetAll();
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'administer site configuration', 'access content', 'administer content types', 'administer nodes', 'bypass node access', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    // Add personalizable field to the article node type.
    $field = array(
      'type' => 'text',
      'field_name' => 'article_headline',
      'cardinality' => -1,
      'settings' => array(
        'personalize' => array(
          'enabled' => 1,
          'agent_type' => 'acquia_lift_target',
          'options' => array(),
          'create_goal' => 1,
        ),
      ),
    );
    field_create_field($field);
    $instance = array(
      'field_name' => 'article_headline',
      'entity_type' => 'node',
      'label' => 'Personalizable Headline',
      'bundle' => 'article',
      'required' => FALSE
    );
    field_create_instance($instance);

    list($node1, $os1, $agent_name) = $this->createPersonalizedField();
    $first_osid = 'osid-' . $os1->osid;
    $goals = personalize_goal_load_by_conditions(array('agent' => $agent_name));
    $this->assertEqual(1, count($goals));
    $goal = reset($goals);
    $action = visitor_actions_custom_load($goal->action);
    $this->assertEqual('click', $action['event']);
    $this->assertEqual('[data-personalize=osid-1]', $action['identifier']);
    $action_name = personalize_generate_machine_name(t('Clicks @option_set', array('@option_set' => $os1->label)), NULL, '_');

    $this->assertEqual($action_name, $action['machine_name']);
    $this->assertTrue($action['limited_use']);

    // Manually set the agent's status to running, bypassing the verification check.
    variable_set(_personalize_agent_get_status_variable($agent_name), PERSONALIZE_STATUS_RUNNING);
    $this->resetAll();
    $expected_action_listeners = array(
      $action_name => array(
        array(
          'agent' => $agent_name,
          'value' => 1
        )
      )
    );
    // Confirm that the goal is in the js settings on the /user page.
    $this->drupalGet('user');
    $settings = $this->drupalGetSettings();
    $this->assertEqual($expected_action_listeners, $settings['personalize']['actionListeners']);

    // Change the field settings to specify particular pages for the goal.
    $edit = array(
      'field[settings][personalize][goal_pages]' => "node"
    );
    $this->drupalPost('admin/structure/types/manage/article/fields/article_headline', $edit, t('Save settings'));
    $this->resetAll();
    // Create another personalized field on a new node.
    list($node2, $os2, $second_agent) = $this->createPersonalizedField();
    // Manually set the agent's status to running, bypassing the verification check.
    variable_set(_personalize_agent_get_status_variable($second_agent), PERSONALIZE_STATUS_RUNNING);
    $this->resetAll();
    $goals = personalize_goal_load_by_conditions(array('agent' => $second_agent));
    $this->assertEqual(1, count($goals));
    $goal = reset($goals);
    // Confirm that the goal is *not* in the js settings on the user page but is
    // on the node page.
    $this->drupalGet('user');
    $settings = $this->drupalGetSettings();
    $this->assertFalse(isset($settings['personalize']['actionListeners'][$goal->action]));

    $this->drupalGet('node');
    $settings = $this->drupalGetSettings();
    $expected_action_listeners[$goal->action] = array(
      array(
        'agent' => $second_agent,
        'value' => 1
      )
    );
    $this->assertEqual($expected_action_listeners, $settings['personalize']['actionListeners']);

    // Now change the field settings to not auto-create a goal.
    $edit = array(
      'field[settings][personalize][create_goal]' => FALSE
    );
    $this->drupalPost('admin/structure/types/manage/article/fields/article_headline', $edit, t('Save settings'));

    list($node3, $os3, $third_agent) = $this->createPersonalizedField();
    $third_osid = 'osid-' . $os3->osid;
    $this->resetAll();
    // Confirm that our agent and option set were created.
    $option_set = personalize_option_set_load($os3->osid);
    $this->assertEqual($third_agent, $option_set->agent);
    // There should be no goal for this agent.
    $goals = personalize_goal_load_by_conditions(array('agent' => $third_agent));
    $this->assertTrue(empty($goals));
  }

  /**
   * Tests campaign javascript settings.
   */
  function testCampaignSettings() {
    module_enable(array('personalize_test_extra_agent'));
    $this->resetAll();
    $this->resetAll();
    // Create two agents of different types.
    $first_agent_name = $this->randomName();
    $first_agent_machine_name = personalize_generate_machine_name($first_agent_name, 'personalize_agent_machine_name_exists');

    $this->createTargetingAgent($first_agent_name);
    $expected = array(
      $first_agent_machine_name => array(
        'name' => $first_agent_machine_name,
        'label' => $first_agent_name,
        'type' => 'acquia_lift_target',
        'links' => array(
          'view' => url('admin/structure/personalize/manage/' . $first_agent_machine_name),
          'edit' => url('admin/structure/personalize/manage/' . $first_agent_machine_name),
          'report' => '',
          'goals' => '/admin/structure/personalize/manage/' . $first_agent_machine_name . '/goals',
          'targeting' => '/admin/structure/personalize/manage/' . $first_agent_machine_name . '/targeting',
          'scheduling' => '/admin/structure/personalize/manage/' . $first_agent_machine_name . '/scheduling',
          'review' => '/admin/structure/personalize/manage/' . $first_agent_machine_name . '/review',
        ),
        'optionSetTypes' => array(),
        'goals' => NULL,
      ),
    );
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content'));
    $this->drupalLogin($admin_user);
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    $this->assertEqual($settings['acquia_lift']['campaigns'][$first_agent_machine_name], $expected[$first_agent_machine_name]);

    // Add a goal to the agent.
    AcquiaLiftAPI::setTestInstance();
    personalize_goal_save($first_agent_machine_name, 'user_login', 3);
    $this->drupalGet('/');
    $settings = $this->drupalGetSettings();
    $expected[$first_agent_machine_name]['goals'] = array(
      'user_login' => 'logs in',
    );
    $this->assertEqual($settings['acquia_lift']['campaigns'][$first_agent_machine_name], $expected[$first_agent_machine_name]);
  }

  /**
   * Creates an article node with a personalized headline field.
   */
  protected  function createPersonalizedField() {
    AcquiaLiftAPI::setTestInstance();
    // Create a node which we will attach a fields-based option set to. We can't
    // do this via the form because of the way we alter the form, which makes the
    // "Add an option" button not findable by simpletest.
    $node = new stdClass();
    $node->type = 'article';
    $node->language = LANGUAGE_NONE;
    node_object_prepare($node);
    $node->title = $this->randomName();
    $node->article_headline['und'][0] = array('value' => 'first value');
    $node->article_headline['und'][1] = array('value' => 'second value');
    node_save($node);

    // Now create the option set.
    $option_set = new stdClass();
    $option_set->is_new = TRUE;
    $option_set->data = array();
    $option_set->options = array();
    $option_set->plugin = 'fields';
    $option_set->new_agent_title = 'Article: Personalizable Headline';
    $option_set->options = array(
      array(
        'option_label' => personalize_fields_generate_option_label(0, array('value' => 'first value'))
      ),
      array(
        'option_label' => personalize_fields_generate_option_label(1, array('value' => 'second value'))
      )
    );
    personalize_fields_option_set_save($option_set, 'node', $node, 'article_headline');
    $this->resetAll();
    $agent_name = $option_set->agent;
    return array($node, $option_set, $agent_name);
  }
}

class AcquiaLiftWebTestTarget extends AcquiaLiftWebTestBase {
  public static function getInfo() {
    return array(
      'name' => t('Acquia Lift Web Tests - Target'),
      'description' => t('Tests functionality related acquia_lift_target personalizations.'),
      'group' => t('Personalize'),
    );
  }

  public function setUp() {
    parent::setUp();
    variable_set('acquia_lift_target_enabled', TRUE);
  }

  function testCreateTargetAudiences() {
    module_load_include('inc', 'acquia_lift', 'acquia_lift.admin');
    $agent = $this->createTargetingAgent();
    $this->resetAll();
    $label = $this->randomName();
    $contexts = array(
      array(
        'context' => implode(PERSONALIZE_TARGETING_ADMIN_SEPARATOR, array('some_plugin', 'some_context')),
        'operator' => 'contains',
        'match' => 'ohai'
      ),
      array(
        'context' => implode(PERSONALIZE_TARGETING_ADMIN_SEPARATOR, array('some_plugin', 'some_other_context')),
        'operator' => 'starts',
        'match' => 'stuff'
      ),
      array(
        'context' => implode(PERSONALIZE_TARGETING_ADMIN_SEPARATOR, array('some_other_plugin', 'some_context')),
        'operator' => 'equals',
        'match' => 'kthxbai'
      ),
    );
    // Try saving a target audience without having created an option set.
    $saved = acquia_lift_target_audience_save($label, $agent->machine_name, $contexts, 'AND');
    $this->assertFalse($saved);
    // Now create an option set for the agent.
    $this->createOptionSet(0, array(
      'plugin' => 'blocks',
      'agent' => $agent->machine_name,
      'option_ids' => array('first-choice', 'second-choice', 'third-choice')
    ));
    $this->resetAll();

    // The "everyone else" target audience should have been created and the
    // options assigned to it by default.
    $option_set = acquia_lift_get_option_set_for_targeting($agent->machine_name);
    $expected_targeting = array(ACQUIA_LIFT_TARGETING_EVERYONE_ELSE => array('first-choice', 'second-choice', 'third-choice'));
    $agent = personalize_agent_load($agent->machine_name);
    $this->assertEqual($expected_targeting, $agent->data['lift_targeting']);

    $saved = acquia_lift_target_audience_save($label, $agent->machine_name, $contexts, 'AND');
    $this->assertTrue($saved);

    // Check that the expected targeting rules were saved on the option set.
    $option_set = personalize_option_set_load($option_set->osid, TRUE);
    $this->assertNotNull($option_set->targeting);
    $audience_name = personalize_generate_machine_name($label, NULL, '-');
    $expected_targeting = array(
      ACQUIA_LIFT_TARGETING_EVERYONE_ELSE => array(
        'label' => t('Everyone else'),
        'weight' => 1,
        'targeting_features' => array(),
        'targeting_rules' => array(),
        'targeting_strategy' => 'OR',
      ),
      $audience_name => array(
        'label' => $label,
        'weight' => 50,
        'targeting_features' => array(
          'some_context::sc-ohai',
          'some_other_context::ss-stuff',
          'some_context::kthxbai'
        ),
        'targeting_rules' => array(
          'some_context::sc-ohai' => array(
              'context' => 'some_context',
              'operator' => 'contains',
              'match' => 'ohai',
              'plugin' => 'some_plugin',
            ),
          'some_other_context::ss-stuff' => array(
              'context' => 'some_other_context',
              'operator' => 'starts',
              'match' => 'stuff',
              'plugin' => 'some_plugin',
            ),
          'some_context::kthxbai' => array(
              'context' => 'some_context',
              'operator' => 'equals',
              'match' => 'kthxbai',
              'plugin' => 'some_other_plugin',
            ),
        ),
        'targeting_strategy' => 'AND',
      )
    );
    $this->assertEqual($expected_targeting, $option_set->targeting);

    // Add another audience.
    $label = $this->randomName();
    $contexts = array(
      array(
        'context' => implode(PERSONALIZE_TARGETING_ADMIN_SEPARATOR, array('boolean_plugin', 'some_context')),
        'operator' => 'equals',
        'match' => 1
      ),
      array(
        'context' => implode(PERSONALIZE_TARGETING_ADMIN_SEPARATOR, array('boolean_plugin', 'some_other_context')),
        'operator' => 'equals',
        'match' => '0'
      ),
    );
    $this->resetAll();
    $saved = acquia_lift_target_audience_save($label, $agent->machine_name, $contexts, 'OR');
    $this->assertTrue($saved);

    $option_set = personalize_option_set_load($option_set->osid, TRUE);
    $audience_names = array_keys($option_set->targeting);
    $expected_targeting[$audience_names[2]] = array(
      'label' => $label,
      'weight' => 50,
      'targeting_features' => array(
        'some_context::1',
        'some_other_context::0',
      ),
      'targeting_rules' => array(
        'some_context::1' => array(
          'context' => 'some_context',
          'operator' => 'equals',
          'match' => '1',
          'plugin' => 'boolean_plugin',
        ),
        'some_other_context::0' => array(
          'context' => 'some_other_context',
          'operator' => 'equals',
          'match' => '0',
          'plugin' => 'boolean_plugin',
        ),
      ),
      'targeting_strategy' => 'OR',
    );
    $this->assertEqual($expected_targeting, $option_set->targeting);
  }

  function testAssignVariations() {
    module_load_include('inc', 'acquia_lift', 'acquia_lift.admin');
    $agent = $this->createTargetingAgent();
    $this->assertFalse(isset($agent->data['lift_targeting']));
    $this->resetAll();
    $option_set = $this->createOptionSet(0, array(
      'plugin' => 'blocks',
      'agent' => $agent->machine_name,
      'option_ids' => array('first-choice', 'second-choice', 'third-choice')
    ));
    $this->resetAll();
    // Try to set up targeting with a non-existent audience.
    $audience_name = personalize_generate_machine_name($this->randomName(), NULL, '-');
    $targeting = array(
      $audience_name => array('second-choice', 'third-choice')
    );
    try {
      acquia_lift_save_targeting_structure($agent, $targeting);
      $this->fail('Should not reach here');
    }
    catch (AcquiaLiftException $e) {
      $this->assertEqual('Invalid audience', $e->getMessage());
    }
    // Now create the audience and try again.
    $this->createTargetAudience($option_set, $audience_name);
    $this->resetAll();
    try {
      acquia_lift_save_targeting_structure($agent, $targeting);
    }
    catch (AcquiaLiftException $e) {
      $this->fail('Exception thrown when none expected.');
    }
    $this->assertEqual($targeting, $agent->data['lift_targeting']);
  }

  function testImplementTargetingStructure() {
    module_load_include('inc', 'acquia_lift', 'acquia_lift.admin');
    // First, set up our agent, option set, audience and desired targeting
    // structure.
    $agent = $this->createTargetingAgent();

    // Set up some test options for nested tests.
    $agent->data['explore_rate'] = 25;
    $agent->data['control_rate'] = 25;
    $agent->data['decision_style'] = 'adaptive';
    personalize_agent_save($agent);

    $this->resetAll();
    $parent_option_set = $this->createPersonalizedBlock(0, $agent, 3);
    if (empty($parent_option_set)) {
      $this->fail('Could not create option set');
      return;
    }
    // Keep the option ids in an array.
    $option_ids = array();
    foreach ($parent_option_set->options as $option) {
      $option_ids[] = $option['option_id'];
    }

    $this->resetAll();
    $audience_name = personalize_generate_machine_name($this->randomName(), NULL, '-');
    $this->createTargetAudience($parent_option_set, $audience_name);
    $targeting = array(
      $audience_name => array($option_ids[1], $option_ids[2])
    );
    try {
      acquia_lift_save_targeting_structure($agent, $targeting);
    }
    catch (AcquiaLiftException $e) {
      $this->fail('Exception thrown when none expected.');
    }
    // Now implement the targeting structure that is currently just stored in
    // the 'lift_targeting' property.
    AcquiaLiftAPI::setTestInstance();
    acquia_lift_update_targeting($agent);
    // We should have a new nested acquia_lift agent and option set.
    $this->resetAll();
    $agents = personalize_agent_load_by_type('acquia_lift');
    $this->assertEqual(1, count($agents));
    $nested_agent = reset($agents);

    // Confirm the test options properties were set.
    $this->assertEqual($nested_agent->data['decision_style'], 'adaptive');
    $this->assertEqual($nested_agent->data['control_rate'], 25);
    $this->assertEqual($nested_agent->data['explore_rate'], 25);

    $option_sets = personalize_option_set_load_by_agent($nested_agent->machine_name);
    $this->assertEqual(1, count($option_sets));
    $nested_osid = key($option_sets);
    $nested_option_set = reset($option_sets);
    $this->assertEqual('options', $nested_option_set->plugin);
    // Confirm the correct options have been added.
    $expected_options = array(
      array(
        'option_id' => $option_ids[1],
      ),
      array(
        'option_id' => $option_ids[2]
      )
    );
    $this->assertEqual($expected_options, $nested_option_set->options);

    // Confirm this osid is on the original option set's targeting rule for that
    // audience.
    $option_set = personalize_option_set_load($parent_option_set->osid, TRUE);
    $this->assertEqual($nested_osid, $option_set->targeting[$audience_name]['osid']);

    // Create a new target audience and change the structure of our campaign.
    $second_audience = personalize_generate_machine_name($this->randomName(), NULL, '-');
    $this->createTargetAudience($option_set, $second_audience, array(
      array(
        'context' => implode(PERSONALIZE_TARGETING_ADMIN_SEPARATOR, array('some_plugin', 'some_context')),
        'operator' => 'equals',
        'match' => 'kthxbai'
      )
    ));
    $targeting = array(
      $audience_name => array($option_ids[2]),
      $second_audience => array($option_ids[0], $option_ids[1])
    );

    // Update the test options.
    $agent->data['explore_rate'] = 35;
    personalize_agent_save($agent);

    try {
      acquia_lift_save_targeting_structure($agent, $targeting);
    }
    catch (AcquiaLiftException $e) {
      $this->fail('Exception thrown when none expected.');
    }
    $this->resetAll();
    // When we implement the new structure it should delete the existing nested
    // option set and create a new one.
    AcquiaLiftAPI::setTestInstance();
    acquia_lift_update_targeting($agent);
    $this->resetAll();
    $nested_option_set = personalize_option_set_load($nested_osid, TRUE);
    $this->assertFalse($nested_option_set);
    // Check the new agent and option set.
    $agents = personalize_agent_load_by_type('acquia_lift');
    $this->assertEqual(1, count($agents));
    $nested_agent = reset($agents);

    // Confirm the test options properties were set.
    $this->assertEqual($nested_agent->data['decision_style'], 'adaptive');
    $this->assertEqual($nested_agent->data['control_rate'], 25);
    $this->assertEqual($nested_agent->data['explore_rate'], 35);

    $option_sets = personalize_option_set_load_by_agent($nested_agent->machine_name);

    $this->assertEqual(1, count($option_sets));
    $nested_osid = key($option_sets);
    $nested_option_set = reset($option_sets);
    $this->assertEqual('options', $nested_option_set->plugin);
    // Confirm the correct options have been added.
    $expected_options = array(
      array(
        'option_id' => $option_ids[0],
      ),
      array(
        'option_id' => $option_ids[1]
      )
    );
    $this->assertEqual($expected_options, $nested_option_set->options);
    // Confirm this osid is on the original option set's targeting rule for that
    // audience.
    $parent_option_set = personalize_option_set_load($parent_option_set->osid, TRUE);
    $this->assertEqual($nested_osid, $parent_option_set->targeting[$second_audience]['osid']);
    // This audience should not have an option id property.
    $this->assertFalse(isset($parent_option_set->targeting[$second_audience]['option_id']));
    // Confirm the option_id property is now on the original audience.
    $this->assertEqual($option_ids[2], $parent_option_set->targeting[$audience_name]['option_id']);
    // It should no longer have an osid property.
    $this->assertFalse(isset($parent_option_set->targeting[$audience_name]['osid']));

    // Now let's place our personalized block so we can test how it gets rendered.
    $admin_user = $this->drupalCreateUser(array('access administration pages', 'manage personalized content', 'administer blocks'));
    $this->drupalLogin($admin_user);
    $edit = array(
      'blocks[personalize_blocks_' . $parent_option_set->osid . '][region]' => 'content',
    );
    $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));
    $this->drupalLogout();
    $this->drupalGet('');
    $settings = $this->drupalGetSettings();
    // THe parent agent and option set should be in the personalize js settings.
    $this->assertTrue(isset($settings['personalize']['agent_map'][$agent->machine_name]));
    $this->assertTrue(isset($settings['personalize']['option_sets']['osid-' . $parent_option_set->osid]));
    // The nested agent and option set should *not* be in the personlaize js settings.
    $this->assertFalse(isset($settings['personalize']['agent_map'][$nested_agent->machine_name]));
    $this->assertFalse(isset($settings['personalize']['option_sets']['osid-' . $nested_osid]));
    // The nested agent and option set should be in the acquia_lift_target js settings.
    $this->assertTrue(isset($settings['acquia_lift_target']['agent_map'][$nested_agent->machine_name]));
    $this->assertTrue(isset($settings['acquia_lift_target']['option_sets']['osid-' . $nested_osid]));
    // The parent agent and option set should *not* be in the acquia_lift_target js settings.
    $this->assertFalse(isset($settings['acquia_lift_target']['agent_map'][$agent->machine_name]));
    $this->assertEqual(1, count($settings['acquia_lift_target']['option_sets']));

    // Change the targeting structure again to have two nested tests.
    $targeting = array(
      $audience_name => array($option_ids[0], $option_ids[1]),
      $second_audience => array($option_ids[0], $option_ids[2])
    );
    // Update another test option too.
    $agent->data['control_rate'] = 50;
    personalize_agent_save($agent);

    try {
      acquia_lift_save_targeting_structure($agent, $targeting);
    }
    catch (AcquiaLiftException $e) {
      $this->fail('Exception thrown when none expected.');
    }
    $this->resetAll();
    // When we implement the new structure it should not delete the existing nested
    // option set but it should change the audience it belongs to.
    AcquiaLiftAPI::setTestInstance();
    acquia_lift_update_targeting($agent);
    $this->resetAll();
    $nested_option_set = personalize_option_set_load($nested_osid, TRUE);
    $this->assertTrue($nested_option_set);
    // We should have two nested agents each with one option set.
    $agents = personalize_agent_load_by_type('acquia_lift');
    $this->assertEqual(2, count($agents));
    // Find the osid of the new option set so we can check that it has been set
    // on the correct target audience.
    foreach ($agents as $nested) {
      // Verify the test options.
      // Confirm the test options properties were set.
      $this->assertEqual($nested->data['decision_style'], 'adaptive');
      $this->assertEqual($nested->data['control_rate'], 50);
      $this->assertEqual($nested->data['explore_rate'], 35);

      // Find the *new* nested agent.
      if ($nested->machine_name != $nested_agent->machine_name) {
        $option_sets = personalize_option_set_load_by_agent($nested->machine_name);
        $nested_os = reset($option_sets);
        $nested_osid2 = $nested_os->osid;
      }
    }
    if (isset($nested_osid2)) {
      // Confirm that the correct osid is assigend to each of the two target
      // audiences.
      $parent_option_set = personalize_option_set_load($parent_option_set->osid, TRUE);
      $this->assertEqual(3, count($parent_option_set->targeting));
      foreach (array($audience_name => $nested_osid, $second_audience => $nested_osid2) as $audience => $osid) {
        $this->assertEqual($osid, $parent_option_set->targeting[$audience]['osid']);
        $this->assertFalse(isset($parent_option_set->targeting[$audience]['option_id']));
      }
    }
    else {
      $this->fail('Could not find the second option set');
    }
  }

  function testNestedAgentsButtons() {
    $this->drupalLogin($this->managerUser);
    $reset_button_name = 'reset_submit';
    $targeting_agent_no_nesting = $this->createTargetingAgent();
    $this->drupalGet('admin/structure/personalize/manage/' . $targeting_agent_no_nesting->machine_name . '/edit');
    // There are no nested tests so there shouldn't be any buttons relating to
    // test agents.
    $this->assertNoFieldByName($reset_button_name);
    $agent_with_nesting = $this->createTargetingAgentWithNestedTest();
    $this->drupalGet('admin/structure/personalize/manage/' . $agent_with_nesting->machine_name . '/edit');
    // This campaign has a nested test so those buttons should be visible.
    $this->assertFieldByName($reset_button_name);
  }

  protected function createTargetingAgentWithNestedTest($label = NULL, $num_options = 3) {
    module_load_include('inc', 'acquia_lift', 'acquia_lift.admin');
    // First, set up our agent, option set, audience and desired targeting
    // structure.
    $agent = $this->createTargetingAgent();
    $this->resetAll();
    $parent_option_set = $this->createPersonalizedBlock(0, $agent, $num_options);
    if (empty($parent_option_set)) {
      $this->fail('Could not create option set');
      return;
    }
    // Keep the option ids in an array.
    $option_ids = array();
    foreach ($parent_option_set->options as $option) {
      $option_ids[] = $option['option_id'];
    }

    $this->resetAll();
    $audience_name = personalize_generate_machine_name($this->randomName(), NULL, '-');
    $this->createTargetAudience($parent_option_set, $audience_name);
    $targeting = array(
      $audience_name => $option_ids
    );
    try {
      acquia_lift_save_targeting_structure($agent, $targeting);
    }
    catch (AcquiaLiftException $e) {
      $this->fail('Exception thrown when none expected.');
    }
    // Now implement the targeting structure that is currently just stored in
    // the 'lift_targeting' property.
    AcquiaLiftAPI::setTestInstance();
    acquia_lift_update_targeting($agent);
    return $agent;
  }

  /**
   * Helper that adds a target audience using two contexts AND'd together.
   *
   * @param $option_set
   * @param null $machine_name
   * @return null|string
   */
  protected function createTargetAudience($option_set, $machine_name = NULL, $contexts = array()) {
    if (empty($machine_name)) {
      $label = $this->randomName();
      $machine_name = personalize_generate_machine_name($label, NULL, '-');
    }
    if (empty($contexts)) {
      $contexts = array(
        array(
          'context' => implode(PERSONALIZE_TARGETING_ADMIN_SEPARATOR, array('some_plugin', 'some_context')),
          'operator' => 'contains',
          'match' => 'ohai'
        ),
        array(
          'context' => implode(PERSONALIZE_TARGETING_ADMIN_SEPARATOR, array('some_plugin', 'some_other_context')),
          'operator' => 'starts',
          'match' => 'stuff'
        ),
      );
    }

    module_load_include('inc', 'acquia_lift', 'acquia_lift.admin');
    acquia_lift_target_audience_save($machine_name, $option_set->agent, $contexts, 'AND');
    $this->resetAll();
    return $machine_name;
  }
}

class AcquiaLiftWebTestCampaignWizard extends AcquiaLiftWebTestBase {
  public static function getInfo() {
    return array(
      'name' => t('Acquia Lift Web Tests - Personalization Wizard'),
      'description' => t('Tests functionality related to the personalization management wizard.'),
      'group' => t('Personalize'),
    );
  }

  public function setUp() {
    parent::setUp();
    variable_set('acquia_lift_target_enabled', TRUE);
  }

  function testVariationTypeSelect() {
    $block_title_name = 'variations[add_variation][details][block][content][title]';
    $element_url_name = 'variations[add_variation][details][element][content][url]';

    $this->drupalLogin($this->managerUser);
    $agent = $this->createTargetingAgent();

    $this->drupalGet('admin/structure/personalize/manage/' . $agent->machine_name . '/variations');
    // Make sure the type selection is shown by default without any selections.
    $this->assertNoFieldChecked('edit-variations-add-variation-option-set-types-option-set-type-block');
    $this->assertNoFieldChecked('edit-variations-add-variation-option-set-types-option-set-type-element');

    // Actual forms should not be shown yet.
    $this->assertNoFieldByName($block_title_name);
    $this->assertNoFieldByName($element_url_name);

    $edit = array(
      'variations[add_variation][option_set_types][option_set_type]' => 'block',
    );

    $this->drupalPostAJAX(NULL, $edit, 'variations[add_variation][option_set_types][option_set_type]');
    $this->assertFieldByName($block_title_name);
    $this->assertNoFieldByName($element_url_name);

    $this->drupalGet('admin/structure/personalize/manage/' . $agent->machine_name . '/variations');
    // Actual forms should not be shown yet.
    $this->assertNoFieldByName($block_title_name);
    $this->assertNoFieldByName($element_url_name);

    $edit = array(
      'variations[add_variation][option_set_types][option_set_type]' => 'element',
    );

    $this->drupalPostAJAX(NULL, $edit, 'variations[add_variation][option_set_types][option_set_type]');
    $this->assertNoFieldByName($block_title_name);
    $this->assertFieldByName($element_url_name);
  }

  /**
   * Test block variation set creation.
   */
  function testWhatBlockForm() {
    $this->drupalLogin($this->managerUser);
    $agent = $this->createTargetingAgent();
    // Create a personalized block from existing blocks.
    $this->drupalGet('admin/structure/personalize/manage/' . $agent->machine_name . '/variations');
    // Indicate a block variation set type.
    $edit = array(
      'variations[add_variation][option_set_types][option_set_type]' => 'block',
    );
    $this->drupalPostAJAX(NULL, $edit, 'variations[add_variation][option_set_types][option_set_type]');

    $edit = array(
      'variations[add_variation][option_set_types][option_set_type]' => 'block',
      'variations[add_variation][details][block][content][title]' => 'Muppets',
      'variations[add_variation][details][block][content][pblock_wrapper][blocks][0][block][bid]' => 'comment_delta_recent',
      'variations[add_variation][details][block][content][pblock_wrapper][blocks][1][block][bid]' => 'node_delta_recent',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_next'));

    $option_sets = personalize_option_set_load_by_agent($agent->machine_name);
    $this->assertEqual(count($option_sets), 1);

    $option_set = reset($option_sets);
    $this->assertEqual(count($option_set->options), 2);
    $this->assertEqual($option_set->label, t('Muppets'));
    $this->assertEqual($option_set->options[0]['option_label'], 'Option A');
    $this->assertEqual($option_set->options[0]['bid'], 'comment_delta_recent');
    $this->assertEqual($option_set->options[1]['option_label'], 'Option B');
    $this->assertEqual($option_set->options[1]['bid'], 'node_delta_recent');

    // Now go to the variations page and verify the new option set is available.
    $this->resetAll();
    $this->drupalGet('admin/structure/personalize/manage/' . $agent->machine_name . '/variations');
    $this->assertFieldByName('variations[option_sets][option_set_1][content][title]', 'Muppets');
    $this->assertOptionSelected('edit-variations-option-sets-option-set-1-content-pblock-wrapper-blocks-0-block-bid', 'comment_delta_recent');
    $this->assertOptionSelected('edit-variations-option-sets-option-set-1-content-pblock-wrapper-blocks-1-block-bid', 'node_delta_recent');

    // Edit the variation set title change the second block to a new block
    // created inline.
    $edit = array(
      'variations[option_sets][option_set_1][content][title]' => 'Great Muppet Caper',
      'variations[option_sets][option_set_1][content][pblock_wrapper][blocks][0][block][bid]' => 'comment_delta_recent',
      'variations[option_sets][option_set_1][content][pblock_wrapper][blocks][1][block][bid]' => '',
      'variations[option_sets][option_set_1][content][pblock_wrapper][blocks][1][block][add][title]' => 'Kermit',
      'variations[option_sets][option_set_1][content][pblock_wrapper][blocks][1][block][add][info]' => 'Piggy',
      'variations[option_sets][option_set_1][content][pblock_wrapper][blocks][1][block][add][body][value]' => 'complicated',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_next'));

    $option_sets = personalize_option_set_load_by_agent($agent->machine_name, TRUE);
    $this->assertEqual(count($option_sets), 1);

    $option_set = reset($option_sets);
    $this->assertEqual(count($option_set->options), 2);
    $this->assertEqual($option_set->label, 'Great Muppet Caper');
    $this->assertEqual($option_set->options[1]['bid'], 'block_delta_1');

    // Now go to the variations page test the advanced options
    $this->resetAll();
    $this->drupalGet('admin/structure/personalize/manage/' . $agent->machine_name . '/variations');

    $edit = array(
      'variations[option_sets][option_set_1][advanced][decision_name]' => 'decision updated',
      'variations[option_sets][option_set_1][advanced][stateful]' => 1,
      'variations[option_sets][option_set_1][advanced][preview_link]' => 'invalid url',
      'variations[option_sets][option_set_1][advanced][executor]' => 'callback',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_next'));

    $this->assertText('You have specified an invalid path');
    $edit['variations[option_sets][option_set_1][advanced][preview_link]'] = '<front>';

    $this->drupalPost(NULL, $edit, $this->getButton('wizard_next'));

    $option_sets = personalize_option_set_load_by_agent($agent->machine_name, TRUE);
    $this->assertEqual(count($option_sets), 1);

    $option_set = reset($option_sets);
    $this->assertEqual(count($option_set->options), 2);
    $this->assertEqual($option_set->label, 'Great Muppet Caper');
    $this->assertEqual($option_set->decision_name, 'decision-updated');
    $this->assertEqual($option_set->stateful, 1);
    $this->assertEqual($option_set->preview_link, '<front>');
    $this->assertEqual($option_set->executor, 'callback');
  }

  /**
   * Test element variation set creation.
   */
  function testWhatElementForm() {
    $this->drupalLogin($this->managerUser);
    $agent = $this->createTargetingAgent();
    $this->drupalGet('admin/structure/personalize/manage/' . $agent->machine_name . '/variations');
    // Indicate an element variation set type.
    $edit = array(
      'variations[add_variation][option_set_types][option_set_type]' => 'element',
    );
    $this->drupalPostAJAX(NULL, $edit, 'variations[add_variation][option_set_types][option_set_type]');

    // Invalid url
    $edit = array(
      'variations[add_variation][details][element][content][url]' => 'invalid url',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_element_navigate'));
    $this->assertText('You have specified an invalid path');

    // Valid external url
    $edit = array(
      'variations[add_variation][details][element][content][url]' => 'http://www.google.com',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_element_navigate'));
    $this->assertNoText('You have specified an invalid path');
    $this->assertUrl('http://www.google.com/');

    // Valid url by alias
    $this->drupalGet('admin/structure/personalize/manage/' . $agent->machine_name . '/variations');
    $edit = array(
      'variations[add_variation][option_set_types][option_set_type]' => 'element',
    );
    $this->drupalPostAJAX(NULL, $edit, 'variations[add_variation][option_set_types][option_set_type]');
    $edit = array(
      'variations[add_variation][details][element][content][url]' => 'admin/structure',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_element_navigate'));
    $this->assertNoText('You have specified an invalid path');
    $this->assertUrl('admin/structure');

    // Valid url by path
    $this->drupalGet('admin/structure/personalize/manage/' . $agent->machine_name . '/variations');
    // Indicate an element variation set type.
    $edit = array(
      'variations[add_variation][option_set_types][option_set_type]' => 'element',
    );
    $this->drupalPostAJAX(NULL, $edit, 'variations[add_variation][option_set_types][option_set_type]');
    $edit = array(
      'variations[add_variation][details][element][content][url]' => 'node',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_element_navigate'));
    $this->assertNoText('You have specified an invalid path');
    $this->assertUrl('node');

    // Check the settings for toolbar integration.
    $settings = $this->drupalGetSettings();
    $this->assertEqual($settings['acquia_lift']['toolbarEditMode'], 'element');

    // Now navigate to another page and make sure that the settings are gone.
    $this->drupalGet('admin/structure/personalize');
    $settings = $this->drupalGetSettings();
    $this->assertTrue(empty($settings['acquia_lift']['toolbarEditMode']));

    // Create an element variation for our agent.
    $option_set = array(
      'label' => 'Element test set 1',
      'plugin' => 'elements',
      'agent' => $agent->machine_name,
      'executor' => 'personalizeElements',
      'options' => array(
        array(
          'option_label' => PERSONALIZE_CONTROL_OPTION_LABEL,
          'option_id' => PERSONALIZE_CONTROL_OPTION_ID,
          'personalize_elements_content' => '',
        ),
        array(
          'option_label' => 'Option A',
          'option_id' => 'option-a',
          'personalize_elements_content' => 'With our very special guest star',
        ),
      ),
      'data' => array(
        'personalize_elements_selector' => '#some-selector',
        'personalize_elements_type' => 'editText',
        'pages' => 'node',
      ),
    );
    personalize_option_set_save((object) $option_set);
    // Go to the edit page and verify that this option set is displayed and
    // links to its "pages" page for editing.
    $this->drupalGet('admin/structure/personalize/manage/' . $agent->machine_name . '/variations');
    $this->assertText('Element test set 1');
    $this->drupalPost(NULL, NULL, 'Edit variation set');
    $this->assertUrl('node');
  }

  /**
   * Verify that audience-style targeting is only available for Acquia Lift
   * Target agents.
   */
  function testAudienceAvailability() {
    $target_agent_data = $this->createTargetingAgent();

    $target_name = $target_agent_data->machine_name;

    // No audiences should show before option sets are created.
    $this->drupalGet('admin/structure/personalize/manage/' . $target_name . '/targeting');
    $this->assertNoFieldByName('audiences[add][details][name]');
    $this->assertText('You must create variation sets before targeting.');

    // Now add an option set.
    $this->createOptionSet(1, array(
      'agent' => $target_name,
      'plugin' => 'type1',
      'num_options' => 2,
    ));

    $this->drupalGet('admin/structure/personalize/manage/' . $target_name . '/targeting');
    $this->assertFieldByName('audiences[add][details][name]');
    $this->assertNoText('You must create variation sets before targeting.');
  }

  /**
   * Test the audience functionality.
   */
  function testTargeting() {
    $first_agent = $this->createTargetingAgent();
    $first_option_set = $this->createOptionSet(1, array(
      'agent' => $first_agent->machine_name,
      'plugin' => 'type1',
      'num_options' => 3,
    ));
    $option_id_1 = $first_option_set->options[0]['option_id'];
    $option_id_2 = $first_option_set->options[1]['option_id'];
    $option_id_3 = $first_option_set->options[2]['option_id'];

    // Create user profile fields that we can use for targeting.
    $user_profile_field_1 = $this->createUserProfileField();
    $context_1 = str_replace('field_', '', $user_profile_field_1['field_name']);

    $this->drupalGet('admin/structure/personalize/manage/' . $first_agent->machine_name . '/targeting');
    $edit = array(
      'audiences[add][details][name]' => 'Muppet fans',
      'audiences[add][details][mapping][contexts][0][context]' => 'user_profile_context' . PERSONALIZE_TARGETING_ADMIN_SEPARATOR . $context_1,
      'audiences[add][details][mapping][contexts][0][value][match]' => 'some value',
      'audiences[add][details][mapping][contexts][0][value][operator]' => 'equals',
      'audiences[add][details][strategy]' => 'OR',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_next'));

    $this->drupalGet('admin/structure/personalize/manage/' . $first_agent->machine_name . '/targeting');

    // Now there should be an existing audience as well as a form to create
    // a new audience.
    $this->assertFieldByName('audiences[muppet-fans][details][name]', 'Muppet fans');
    $this->assertFieldByName('audiences[add][details][name]', '');

    // Add a new audience and edit the existing audience.
    $edit = array(
      'audiences[muppet-fans][details][name]' => 'Muppet mania',
      'audiences[muppet-fans][details][mapping][contexts][0][value][match]' => 'Kermit fans',
      'audiences[add][details][name]' => 'Others',
      'audiences[add][details][mapping][contexts][0][context]' => 'user_profile_context' . PERSONALIZE_TARGETING_ADMIN_SEPARATOR . $context_1,
      'audiences[add][details][mapping][contexts][0][value][operator]' => 'equals',
      'audiences[add][details][mapping][contexts][0][value][match]' => 'Sad people',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_next'));

    $this->drupalGet('admin/structure/personalize/manage/' . $first_agent->machine_name . '/targeting');

    // Now there should be two existing audiences as well as a form to create
    // a new audience.
    $this->assertFieldByName('audiences[muppet-fans][details][name]', 'Muppet mania');
    $this->assertFieldByname('audiences[muppet-fans][details][mapping][contexts][0][value][match]', 'Kermit fans');
    $this->assertFieldByName('audiences[others][details][name]', 'Others');
    $this->assertFieldByName('audiences[others][details][mapping][contexts][0][context]', 'user_profile_context' . PERSONALIZE_TARGETING_ADMIN_SEPARATOR . $context_1);
    $this->assertOptionSelected('edit-audiences-others-details-mapping-contexts-0-value-operator', 'equals');
    $this->assertFieldByName('audiences[others][details][mapping][contexts][0][value][match]', 'Sad people');
    $this->assertFieldByName('audiences[add][details][name]', '');

    // Adjust the weights and verify that the "Everyone else" has the highest.
    module_load_include('inc', 'acquia_lift', 'acquia_lift.admin');
    $this->drupalGet('admin/structure/personalize/manage/' . $first_agent->machine_name . '/targeting');
    $edit = array(
      'audiences[muppet-fans][details][weight]' => 50,
      'audiences[others][details][weight]' => 75,
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_next'));
    $this->drupalGet('admin/structure/personalize/manage/' . $first_agent->machine_name . '/targeting');
    $option_set = acquia_lift_get_option_set_for_targeting($first_agent->machine_name);
    $this->assertEqual($option_set->targeting['muppet-fans']['weight'], 50);
    $this->assertEqual($option_set->targeting['others']['weight'], 75);
    $this->assertEqual($option_set->targeting['everyone-else']['weight'], 85);

    $edit = array(
      'audiences[muppet-fans][details][weight]' => 5,
      'audiences[others][details][weight]' => 0,
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_next'));
    $this->resetAll();
    $option_set = acquia_lift_get_option_set_for_targeting($first_agent->machine_name);
    $this->assertEqual($option_set->targeting['muppet-fans']['weight'], 5);
    $this->assertEqual($option_set->targeting['others']['weight'], 0);
    $this->assertEqual($option_set->targeting['everyone-else']['weight'], 15);
    $first_agent = personalize_agent_load($first_agent->machine_name);

    // Test assignments saves as anticipated.
    $this->drupalGet('admin/structure/personalize/manage/' . $first_agent->machine_name . '/targeting');
    // There are no targeting assignments so there should be no messages.
    $this->assertNoText('The targeting settings shown here do not match what is currently running for this personalization.');
    $this->assertNoText('The targeting settings shown here represent what is currently running for this personalization.');
    // All variations should be assigned to the "Everyone else" audience.
    $this->assertOptionSelected('edit-audiences-everyone-else-assignment', $option_id_1);
    $this->assertOptionSelected('edit-audiences-everyone-else-assignment', $option_id_2);
    $this->assertOptionSelected('edit-audiences-everyone-else-assignment', $option_id_3);
    // The other audiences should not have any assignments by default.
    $this->assertNoOptionSelected('edit-audiences-muppet-fans-assignment', $option_id_1);
    $this->assertNoOptionSelected('edit-audiences-muppet-fans-assignment', $option_id_2);
    $this->assertNoOptionSelected('edit-audiences-muppet-fans-assignment', $option_id_3);
    $this->assertNoOptionSelected('edit-audiences-others-assignment', $option_id_1);
    $this->assertNoOptionSelected('edit-audiences-others-assignment', $option_id_2);
    $this->assertNoOptionSelected('edit-audiences-others-assignment', $option_id_3);

    $edit = array(
      'audiences[muppet-fans][assignment_order]' => $option_id_1 . ',' . $option_id_2,
      'audiences[others][assignment_order]' => $option_id_3,
      'audiences[everyone-else][assignment_order]' => $option_id_1,
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_next'));
    // The targeting should be saved in the agent property.
    $first_agent = personalize_agent_load($first_agent->machine_name, TRUE);
    $expected_agent_targeting = array(
      'muppet-fans' =>  array($option_id_1, $option_id_2),
      'others' => array($option_id_3),
      'everyone-else' => array($option_id_1),
    );
    $this->assertEqual($expected_agent_targeting, $first_agent->data['lift_targeting']);
    // The targeting should not have been saved to the option set yet.
    acquia_lift_get_structure_from_targeting(personalize_option_set_load($first_option_set->osid, TRUE));
    $this->assertTrue(empty($option_set->targeting['muppet-fans']['option_id']));
    $this->assertTrue(empty($option_set->targeting['muppet-fans']['osid']));
    $this->assertTrue(empty($option_set->targeting['others']['option_id']));
    $this->assertTrue(empty($option_set->targeting['others']['osid']));
    $this->assertTrue(empty($option_set->targeting['everyone-else']['option_id']));
    $this->assertTrue(empty($option_set->targeting['everyone-else']['osid']));

    // A message should not display to indicate that the targeting isn't
    // finalized because the agent is still not started.
    $this->drupalGet('admin/structure/personalize/manage/' . $first_agent->machine_name . '/targeting');
    $this->assertNoText('The targeting settings shown here do not match what is currently running for this personalization.');
    $this->assertNoText('The targeting settings shown here represent what is currently running for this personalization.');

    // Save the targeting structure and start the agent.
    acquia_lift_update_targeting($first_agent);
    personalize_agent_set_status($first_agent->machine_name, PERSONALIZE_STATUS_RUNNING);
    $this->resetAll();

    $this->drupalGet('admin/structure/personalize/manage/' . $first_agent->machine_name . '/targeting');
    $this->assertNoText('The targeting settings shown here do not match what is currently running for this personalization.');
    $this->assertText('The targeting settings shown here represent what is currently running for this personalization.');

    // Make changes and verify the messaging.
    $edit = array(
      'audiences[muppet-fans][assignment_order]' => $option_id_2,
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_next'));
    $this->drupalGet('admin/structure/personalize/manage/' . $first_agent->machine_name . '/targeting');
    $this->assertText('The targeting settings shown here do not match what is currently running for this personalization.');
    $this->assertNoText('The targeting settings shown here represent what is currently running for this personalization.');

    // Revert the changes and verify.
    $this->drupalPost(NULL, NULL, t('Revert changes'));
    $this->assertText(t('Are you sure you want to revert the targeting changes'));
    $this->drupalPost(NULL, NULL, t('Revert changes'));
    $this->resetAll();

    $this->drupalGet('admin/structure/personalize/manage/' . $first_agent->machine_name . '/targeting');
    $this->assertNoText('The targeting settings shown here do not match what is currently running for this personalization.');
    $this->assertText('The targeting settings shown here represent what is currently running for this personalization.');
    $this->assertOptionSelected('edit-audiences-muppet-fans-assignment', $first_option_set->options[0]['option_id']);
    $this->assertOptionSelected('edit-audiences-muppet-fans-assignment', $first_option_set->options[1]['option_id']);
    $this->assertOptionSelected('edit-audiences-others-assignment', $first_option_set->options[2]['option_id']);
    $this->assertOptionSelected('edit-audiences-everyone-else-assignment', $first_option_set->options[0]['option_id']);

    // Add an option to the existing option set and verify that it appears as
    // unassigned but available for targeting.
    $unassigned_id = personalize_generate_option_id(3);
    $first_option_set->options[] = array(
      'option_id' => $unassigned_id,
      'option_label' => personalize_generate_option_label(3),
    );
    personalize_option_set_save($first_option_set);

    $this->drupalGet('admin/structure/personalize/manage/' . $first_agent->machine_name . '/targeting');
    $this->assertOptionSelected('edit-variations-options-assignment', $unassigned_id);
    $this->assertOptionSelected('edit-variations-options-assignment', $first_option_set->options[0]['option_id']);
    $this->assertOptionSelected('edit-variations-options-assignment', $first_option_set->options[1]['option_id']);
    $this->assertOptionSelected('edit-variations-options-assignment', $first_option_set->options[2]['option_id']);
    $this->assertOptionSelected('edit-audiences-muppet-fans-assignment', $first_option_set->options[0]['option_id']);
    $this->assertOptionSelected('edit-audiences-muppet-fans-assignment', $first_option_set->options[1]['option_id']);
    $this->assertOptionSelected('edit-audiences-others-assignment', $first_option_set->options[2]['option_id']);
    $this->assertOptionSelected('edit-audiences-everyone-else-assignment', $first_option_set->options[0]['option_id']);
  }

  /**
   * Test goals form.
   */
  function testGoals() {
    $this->drupalLogin($this->managerUser);
    $agent = $this->createTargetingAgent();

    $element_action = 'action_name';
    $page_event = 'event[page]';

    $this->drupalGet('admin/structure/personalize/manage/' . $agent->machine_name . '/goals');
    // The type selection should be shown by default when there are no goals.
    $this->assertNoFieldChecked('edit-goals-add-goal-goal-types-goal-type-existing');
    $this->assertNoFieldChecked('edit-goals-add-goal-goal-types-goal-type-page');
    $this->assertNoFieldChecked('edit-goals-add-goal-goal-types-goal-type-element');

    // Actual forms should not be shown yet.
    $this->assertNoFieldByName($element_action);
    $this->assertNoFieldByName($page_event);

    // Check existing form.
    $edit = array(
      'goals[add_goal][goal_types][goal_type]' => 'existing',
    );
    $this->drupalPostAJAX(NULL, $edit, 'goals[add_goal][goal_types][goal_type]');
    $this->assertNoFieldByName($page_event);
    $this->assertFieldByName($element_action);

    // Add an existing goal.
    $edit = array(
      $element_action => 'user_login',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_save'));

    $this->assertOptionSelected('edit-goals-all-goals-0-action-name', 'user_login');
    $this->assertFieldByName('goals[all_goals][0][value]', 1);

    // Add a page goal.
    $edit = array(
      'goals[add_goal][goal_types][goal_type]' => 'page',
    );
    $this->drupalPostAJAX(NULL, $edit, 'goals[add_goal][goal_types][goal_type]');

    $this->assertFieldByName($page_event);
    $this->assertNoFieldByName($element_action);

    $edit = array(
      'title' => 'Test goal',
      $page_event => 'client::scrollToBottom',
      'pages' => 'node',
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_save'));

    $this->assertOptionSelected('edit-goals-all-goals-1-action-name', 'test_goal');
    $this->assertFieldByName('goals[all_goals][1][value]', 1);

    // Edit the new goal.
    $edit = array(
      'goals[all_goals][1][action_name]' => 'form_submit',
      'goals[all_goals][1][value]' => 5,
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_save'));

    // Verify everything is as expected.
    $this->assertNoFieldChecked('edit-goals-add-goal-goal-types-goal-type-existing');
    $this->assertNoFieldChecked('edit-goals-add-goal-goal-types-goal-type-page');
    $this->assertNoFieldChecked('edit-goals-add-goal-goal-types-goal-type-element');
    $this->assertOptionSelected('edit-goals-all-goals-0-action-name', 'user_login');
    $this->assertFieldByName('goals[all_goals][0][value]', 1);
    $this->assertOptionSelected('edit-goals-all-goals-1-action-name', 'form_submit');
    $this->assertFieldByName('goals[all_goals][1][value]', 5);

    // Make sure all goals saved as expected too.
    $goal_entities = personalize_goal_load_by_conditions(array('agent' => $agent->machine_name));
    $test_goals = array_values($goal_entities);
    $this->assertEqual(count($test_goals), 2);
    $this->assertEqual($test_goals[0]->action, 'user_login');
    $this->assertEqual($test_goals[0]->value, 1);
    $this->assertEqual($test_goals[1]->action, 'form_submit');
    $this->assertEqual($test_goals[1]->value, 5);
  }

  /**
   * Test the review form.
   */
  function testReviewForm() {
    $this->drupalLogin($this->managerUser);
    $agent = $this->createTargetingAgent();

    // There are no tests yet so the review page should not show any test
    // options.
    $this->drupalGet("admin/structure/personalize/manage/{$agent->machine_name}/review");
    $this->assertNoFieldByName('decision_style');
    $this->assertNoFieldByName('control_rate');
    $this->assertNoFieldByName('explore_rate');

    $this->createOptionSet(1, array(
      'agent' => $agent->machine_name,
      'plugin' => 'type1',
      'num_options' => 2,
    ));

    // Options will be automatically added to the "Everyone else" audience
    // which means that there will be two options to test against.
    $this->drupalGet("admin/structure/personalize/manage/{$agent->machine_name}/review");
    $this->assertNoText('Test options cannot be edited while this personalization is running.');
    $edit = array(
      'decision_style' => 'adaptive',
      'control_rate' => 25,
      'explore_rate' => 25,
    );
    $this->drupalPost(NULL, $edit, $this->getButton('wizard_save'));

    $this->resetAll();
    $agent = personalize_agent_load($agent->machine_name);
    $this->assertEqual($agent->data['decision_style'], 'adaptive');
    $this->assertEqual($agent->data['control_rate'], '25');
    $this->assertEqual($agent->data['explore_rate'], 25);

    // Start the agent and verify that the options are no longer editable.
    personalize_agent_set_status($agent->machine_name, PERSONALIZE_STATUS_RUNNING);
    $this->resetAll();

    $this->drupalGet("admin/structure/personalize/manage/{$agent->machine_name}/review");
    $this->assertText('Test options cannot be edited while this personalization is running.');
  }
}
